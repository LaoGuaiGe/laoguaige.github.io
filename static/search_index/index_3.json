{"/diy/wiki-web/basic.html":{"title":"wiki网站搭建","content":" title: wiki网站搭建 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 基本架构 使用 teedoc框架搭建，使用github的pages部署而成。 ## teedoc介绍 **简而全的开源静态网站/文档/博客生成器** 1. 使用 Markdown 或者 jupyter notebook 书写，自动生成 HTML 页面 2. 使用 python 编写， 跨平台， 使用 pip 即可安装， 支持插件安装及自定义插件 3. 支持多文档，每篇文档有单独的目录，也可以多版本。你的大量文档再也不用散落在各个域名下了！同时支持轻量博客系统 4. 默认主题为高效阅读而设计，提供主题插件支持，同时支持自定义 css、js，能通过页面指定 id 精确控制任何一个页面元素的样式 5. 并行构建，充分利用处理器性能，文档渲染就在一瞬间，支持浏览器实时预览修改 6. 生成的都是静态页面，拷贝到服务器即可完成部署，SEO 友好，比如 页关键词自定义、sitemap自动生成等 ## teedoc相关资料 官网: teedoc.neucrack.com 或 teedoc.github.io 本文档源文件: github.com/teedoc/teedoc.github.io 源码: https://github.com/teedoc/teedoc 如果你喜欢这个项目，请务必登录 github 给项目点个 star 以下场景可使用teedoc： * 建文档网站，并且最好支持放多份文档（比如你有一本叫Python学习和C++学习两本书，它们都有单独的目录, teedoc则是书库） * 文档和网页页面共存，支持自定义HTML页面 * 建WiKi网站 * 建个人或者企业知识库 * 建个人或者企业网站 * 博客 ## 使用teedoc的企业案例 网站 简介 站点源文档 [teedoc 官网](https://teedoc.github.io) 好用的文档网站生成工具 [teedoc/teedoc.github.io](https://github.com/teedoc/teedoc.github.io) [MaixPy](https://maixpy.sipeed.com) 边缘 AI 计算 Python SDK [sipeed/MaixPy_DOC](https://github.com/sipeed/MaixPy_DOC) [Sipeed Wiki](https://wiki.sipeed.com) Sipeed 官方Wiki [sipeed/sipeed_wiki](https://github.com/sipeed/sipeed_wiki) [teedoc.github.io/re0 web teedoc/](https://teedoc.github.io/re0 web teedoc/) 从 gitbook 转到 teedoc 的示例网站 [teedoc/re0 web teedoc](https://github.com/teedoc/re0 web teedoc) [QuecPython](https://python.quectel.com/doc/) QuecPython 文档中心 [gitee](https://gitee.com/quecpython/Community document) [github](https://github.com/quecpython/Community document) [BPI Steam Doc](https://bpi steam.com/) BananaPi, Steam团队的文档（Wiki），包含了开源软件和开源硬件资料，AIOT资料等等 [BPI STEAM/BPI Doc](https://github.com/BPI STEAM/BPI Doc) [udbg](https://udbg.github.io/) 基于Lua的二进制调试/分析工具 [udbg/udbg.github.io](https://github.com/udbg/udbg.github.io) [VastUtils](https://sakurajimamaii.github.io/VastDocs/) 一款加快你安卓开发的安卓工具集 [SakurajimaMaii/VastDocs](https://github.com/SakurajimaMaii/VastDocs) 期待你的使用， 欢迎[提交 issue](https://github.com/teedoc/teedoc.github.io/issues) 或者 PR 来添加你的网站 ## 快速搭建wiki网站 ### 安装 python3 需要先安装Python3 （仅支持 Python3） 比如在Ubuntu上： ```sh sudo apt install python3 python3 pip git ``` Windows 和 macOS请到[官网下载](https://www.python.org/downloads/) ### 安装 teedoc 打开终端(Windows按Ctrl+R输入cmd)，输入： ```sh pip3 install teedoc ``` 以后使用以下命令来更新软件： ```sh pip3 install teedoc upgrade ``` 如果你的网络使用 pypi.org 速度很慢，可以选择其它源，比如清华 tuna 源： `pip3 install teedoc i https://pypi.tuna.tsinghua.edu.cn/simple` 现在你可以在终端使用 `teedoc` 命令了 如果不能，请检查是不是`Python`可执行目录没有加入到环境变量 `PATH`, 比如可能在 `~/.local/bin` ### 新建工程 新建一个空目录用来放文档工程 ```sh mkdir my_site cd my_site teedoc init ``` 选择1，也就是minimal模板进行生成， 也可以直接`teedoc d my_site template minimal init`进行生成 这会在 `my_site` 目录下自动生成一些基础文件 ### 安装插件 这会根据`site_config.json`中的`plugins`的插件设置安装插件 ```sh cd my_site teedoc install ``` 插件也是以 `python` 包的形式发布的， 所以这会从 `pypi.org` 下载对应的插件，同样，也可以使用其它源，比如清华 tuna 源： `teedoc i https://pypi.tuna.tsinghua.edu.cn/simple install` ### 构建 `HTML` 页面并起一个`HTTP`服务 ```sh teedoc serve ``` 这个命令会先构建所有`HTML`页面以及拷贝资源文件，然后起一个`HTTP`服务 如果只需要生成页面，使用 ```sh teedoc build ``` 在显示 `Starting server at 0.0.0.0:2333 ....` 后，就可以了 打开浏览器访问: `http://127.0.0.1:2333` 同时可以看到目录下多了一个`out`目录，里面就是生成的静态网站内容，直接拷贝到服务器使用`nginx`或者`apache`进行部署即可"},"/diy/picxel-clock/hardware.html":{"title":"硬件设计","content":" title: 硬件设计 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 整体原理图 ![图 0](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 32 53.png) ## 硬件设计 ### 电源部分 第一版时，使用 FM5324G 作为控制。它是一个集成了锂电池充电管理，电池5V升压输出，电池电量判断和 LED 电量指示的集成电源管理 IC。 ![图 1](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 33 12.png) **但是发现使用一个800mAh的电池，开个10分钟就没电了，直接舍弃电源管理部分，直接通过TYPE C接口进行供电。** 当前版： ![图 3](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 33 27.png) 首先，因为语音模块需要有一个下载设备，这里直接将TYPE C接口的数据接口接到了一个CH340N（图中的U9，编号C2977777）的器件上。接下来对各个器件进行说明。 1. R56和R57是USB协议上要求的，必须是5.1K，涉及到PD诱骗电压输出，具体原因自行百度。 2. D8和D7是ESD保护器件，防止静电的，防止静电损坏后级设备，也可以不用这些器件。 3. VBUS通过一个短接符号连接到了5V，说明这个TYPE C输入的是5V，是我的个人习惯，通常可以直接在USB处标记5V。 4. U9就是之前说的CH340N，看[数据手册](https://atta.szlcsc.com/upload/public/pdf/source/20230530/6E401E9554E9F5311886CC8B3F89B62E.pdf)，是一个将USB 转串口的芯片，而我们的语音识别模块就是通过串口下载。 5. C26和C27，首先是C26，在CH340N的数据手册中指出：当CH340N的电压输入为5V时，必须在V3引脚处外接一个100nf的电容；VCC处尽量加一个100NF的电容。 6. R27和D1，根据CH340N的厂家说明，为了防止与CH340N通信的设备，通过RXD和TXD引脚将电压反充给CH340，建议在RXD引脚上接入一个限流电阻，TXD上接一个反向二极管，防止电流电压倒灌。 7. D2也是一个ESD器件，防止类似雷击，静电等导致的瞬间高压损坏设备，加入ESD器件后，可以有效防止瞬间的高压将设备烧毁。 **总结：就是一个通过USB供电的同时，还可以通过USB给语音模块下载语音识别的固件** ### 主控部分 使用立创开发板的[立创·ESP32S3R8N8开发板](https://lckfb.com/project/detail/lckfb esp32s3r8n8?param baseInfo)。 ![图 4](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 33 56.png) 没啥好说的，就是给开发板供电5V就好，开发板上有LDO，输入5V后开发板会输出3V3。这里需要注意，我就是BOT引脚用来接了按键，方便在调试出现故障时，也可以通过进入升级模式，擦除内存。 ### RTC时钟部分 使用常见的一个RTC时钟模块DS1302。特点如下： ![图 5](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 02.png) 原理图设计 ![图 6](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 07.png) DS1302需要外部接一个32.768KHz的晶振作为时钟，就是图中的X1器件。而晶振为了更加的稳定精确，需要在晶振的输入输出加上负载电容，根据那个晶振的手册说明，加了12pf的负载电容，就是图中的C8C9。VCC1是备用电池的电源输入口，如果想要在设备断电的情况下，DS1302还能够跑时，那么必须接入这个B1电池座，这个电池座是接的纽扣电池。C7单纯是滤波用。DS1302的其他引脚就是控制引脚了，将其接到开发板引脚上，方便开发板控制。 ### 温湿度采集部分 又是使用常见的一个温湿度传感器DHT11。特点如下： ![图 7](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 13.png) 原理图设计 ![图 8](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 18.png) DHT11在数据引脚DATA上，必须加一个上拉电阻，让DHT11在空闲时保持高电平。根据它的数据手册，这个上拉电阻就选择了4.7K的R12。然后DHT11是支持3.3V~5V的电压输入的，这里因为开发板是3V3的GPIO电压，所以为了通信稳定，给DHT11的数据引脚DATA的也保持3.3V，给DHT11的输入电压为3.3V。 ### WS2812彩灯矩阵部分 这里购买的是淘宝上卖``36元``的 32 * 8 像素的彩灯矩阵：[WS2812B全彩软像素屏8X8 8X32 16X16幻彩5V显示可编程像素软屏](https://item.taobao.com/item.htm?_u n2t4uge597e5&amp;id 737696448369&amp;skuId 5263566850408&amp;spm a1z09.2.0.0.17c22e8d4Z2Du3) ![图 9](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 25.png) 原理图设计： ![图 10](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 32.png) WS2812是一个单总线的设备，每一个灯珠里面都带了驱动电路，可以同时控制很多个灯，但是为了以防万一，在这个WS2812彩灯矩阵的电源输入口VCC处，加了一个1000UF的电容，防止彩灯矩阵亮的瞬间电压电流不足，加了电容之后，如果出现电压电流不足的情况下，就可以从这个大电容取电。 ### 音频采集部分 关于模拟信号类我不太了解，这里是参考的一个音频采集模块的电路：``MAX4466音频采集模块``，感兴趣的朋友直接上淘宝搜索就好。 ![图 11](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 41.png) 原理图设计： ![图 12](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 45.png) ### 按键部分 在软件部分当中使用一个按键去控制UI界面的切换。但是当前我虽然用上了按键，结果我的外壳部分没有做好，导致我现在切换界面的拆开外壳去按按键... 大家等我完善或者复刻的时候自行完善就好。 原理图设计： ![图 13](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 34 51.png) ## 外壳部分 >! 下载地址：https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/3Dfile ### 3D文件说明 **因为实物很大，打印的外壳需要分开，分左右两边。** LEDGrid2x.stl 为光栏，需要一个部件打两个，拼到一起； > 说明：光栏一定要**黑色的材质，不管是3D打印时选择黑色的材料还是后面收到喷黑漆，一定记得使用黑色的光栏！不然观感就差很多** ![图 0](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 32 35.png) frontFrame2x.stl 为外壳边框，需要一个部件打两个，拼到一起； ![图 1](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 32 50.png) Housing.stl 和 Housing_noV.stl 为同一个部件，选择一个进行打印即可，都是成本较高，酌情打印； ![图 2](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 32 57.png) 如要组建完整的外壳，还需要购买黑色的亚克力透明面板！ ``生产的规格参数：黑茶色 透明亚克力 95×330×2mm`` ## 项目展示 ### 静态图 ![图 14](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 36 12.png) ### 动态图 ![图 15](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 36 36.gif) ![图 16](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 36 45.gif) ![图 17](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 36 54.gif) ![图 18](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 37 07.gif) ![图 19](../../static/images/docs/diy/picxel clock/hardware/hardware 2024 12 06 00 37 16.gif)"},"/diy/picxel-clock/ntptime.html":{"title":"获取网络时间","content":" title: 获取网络时间 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## NTP介绍 NTP网络时间协议（Network Time Protocol，NTP），是一种用于在计算机网络上同步时间的协议。它通过在时间服务器和客户端之间交换时间信息来确保网络中的计算机时钟保持准确的时间同步。以下是NTP的一些关键特性： **特点** **精确性：** NTP能够提供非常高的时间同步精度，通常在毫秒级，甚至可以达到微秒级。 **可扩展性：** NTP设计用于在广泛的网络环境中工作，从局域网到广域网，可以支持大量客户端。 **分层结构：** NTP采用层级化的时间同步架构，时间信息从高精度的参考时钟源通过多个时间服务器层传递到客户端。 **鲁棒性：** NTP能够处理网络延迟、丢包和其他网络问题，确保时间同步的稳定性和可靠性。 **应用** **服务器同步：** 确保服务器集群中的所有服务器时钟同步。 **网络安全：** 在网络安全中，同步的时钟对于日志记录和事件关联至关重要。 **分布式系统：** 在分布式系统和数据库中，准确的时间同步有助于维护数据一致性和协调操作。 **NTP广泛应用于互联网上的各种设备和系统中，是现代网络基础设施的重要组成部分。** > 以上来自 chatGPT 的介绍 ## 硬件准备 因为项目要有网络时间校准功能，要使用WIFI获取网络时间进行校准。这里使用的是ESP32S3的开发板。 > **购买地址：**[立创·ESP32S3R8N8 开发板](https://item.szlcsc.com/22034693.html?fromZone s_s__%2522%25E7%25AB%258B%25E5%2588%259B%25E5%25BC%2580%25E5%258F%2591%25E6%259D%25BF%2522) ![图 1](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 14 24.png) ## 工程创建 在VSCode中打开PlatformIO扩展创建名为`ntpTime`的 `Espressif ESP32 S3 DevKitM 1` 工程。 关于详细图文创建工程的过程请参考👉[RTC时钟驱动](ds1302.html)章节的工程创建小节。 ## 安装驱动库 在驱动库安装界面，搜索``NTPClient``，安装来自``Fabrice Weinberg`` 的 ``NTPClient``库。 > 关于详细图文安装驱动库的过程请参考👉[RTC时钟驱动](ds1302.html)章节的安装驱动库小节。 安装完成之后，打开``platformio.ini``文件，可以看到已经安装上了驱动库。 ![图 1](../../static/images/docs/diy/picxel clock/ntptime/ntptime 2024 12 05 23 43 21.png) ## 编辑代码 打开工程下的``src``文件夹下的``main.cpp``。 输入以下代码： ```c #include <Arduino.h> #include <WiFi.h> #include <NTPClient.h> #include <WiFiUdp.h> //设置你要ESP32S3连接的WIFI名称 #define WIFI_SSID \"lckfb\" //设置你要ESP32S3连接的WIFI密码 #define WIFI_PASS \"12345678\" // 定义NTP服务器 const char* ntpServer \"pool.ntp.org\"; // 定义时区（以小时为单位，例如：+1或 3） const long gmtOffset 8; // 定义夏令时（Daylight Saving Time，DST）的偏移量（通常为0或3600秒） const int daylightOffset 0; // 创建UDP实例 WiFiUDP ntpUDP; // 创建NTP客户端实例 NTPClient timeClient(ntpUDP, ntpServer, gmtOffset * 3600, daylightOffset * 3600); void setup() { //初始化串口 Serial.begin(9600); // 连接到Wi Fi WiFi.begin(WIFI_SSID, WIFI_PASS); //如果没有连接上串口就一直输出 ... //如果连接不上请确保你要连接的WIFI不是5G频段! //大部分ESP32系列都只能连接2.4G频段! while (WiFi.status() ! WL_CONNECTED) { delay(500); Serial.print(\".\"); } // 启动NTP客户端 timeClient.begin(); // 设置时间同步间隔（以毫秒为单位） timeClient.setUpdateInterval(60000); // 1分钟更新一次 } void loop() { // 更新NTP时间 timeClient.update(); if (timeClient.getEpochTime() > 0) { // 获取成功 unsigned long epochTime timeClient.getEpochTime(); struct tm *ptm gmtime ((time_t *)&epochTime); //年是至1900年后开始计算,所以我们实际使用得+1900 int year ptm >tm_year + 1900; //月是从0开始算,所以我们实际使用得+1 int month ptm >tm_mon + 1; int day ptm >tm_mday; int hour ptm >tm_hour; int minute ptm >tm_min; int second ptm >tm_sec; // 打印时间 Serial.printf(\"%d %02d %02d %02d:%02d:%02d\\n\", year, month, day, hour, minute, second); } else { // 获取失败，可以在这里进行重试或错误处理 Serial.println(\"Failed to get NTP time\"); } delay(1000); // 每1秒尝试一次 } ``` ## 代码验证 代码编写完成之后，将ESP32S3开发板接入电脑下载代码，然后打开串口监视器查看现象。 > 下载步骤请参考👉[RTC时钟驱动](ds1302.html)章节的代码验证小节。 实际获取网络时间的效果如下： ![图 2](../../static/images/docs/diy/picxel clock/ntptime/ntptime 2024 12 05 23 44 35.png) **后续我们使用到硬件的RTC时钟模块时，就可以通过NTP的方式获取网络的时间进行校准了。** >! 说明：如果你根据代码操作运行不起来，可以下载👉[例程](https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/example/ntpTime)看看"},"/diy/picxel-clock/dht11.html":{"title":"温湿度读取","content":" title: 温湿度读取 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 工程创建 在VSCode中打开PlatformIO扩展创建名为`dht11`的 `Espressif ESP32 S3 DevKitM 1` 工程。 关于详细图文创建工程的过程请参考👉[RTC时钟驱动](ds1302.html)章节的工程创建小节。 ## 安装驱动库 往工程中安装来自``Adafruit``的``DHT sensor library``库。 可以打开``platformio.ini``文件，验证工程是否已经安装上了``DHT11``的驱动库。 关于详细图文安装驱动库的过程请参考👉[RTC时钟驱动](ds1302.html)章节的安装驱动库小节。 ## 编辑代码 打开工程下的src文件夹下的main.cpp。 输入以下代码： ```c #include <Arduino.h> #include <Adafruit_Sensor.h> #include <DHT.h> //温湿度传感器驱动库 //DHT11温湿度传感器相关定义 #define DHTPIN 4 //传感器引脚连接4 #define DHTTYPE DHT11 //传感器支持DHT11, DHT12, DHT21, DHT22, AM2301 DHT dht(DHTPIN, DHTTYPE); //初始化温湿度传感器 //湿度 和 温度 的全局变量 float humidity 0, temperature 0; //温湿度传感器数值读取 void readDHT(void) { //读取温度参数保存到全局变量中 humidity dht.readHumidity(); //读取湿度参数保存到全局变量中 temperature dht.readTemperature(); //判断温湿度数据是否是非数字 if (isnan(humidity) isnan(temperature)) { Serial.println(\"Failed to read from DHT sensor!\"); return; } } void setup() { //串口初始化 Serial.begin(9600); //DHT11初始化 dht.begin(); } void loop() { char disp_buf[50] {0}; readDHT(); //读取温湿度参数 //格式化字符串 sprintf(disp_buf, \"temperature %02.0d C\", (int)temperature); //输出温度 Serial.println(disp_buf); //格式化字符串 sprintf(disp_buf, \"humidity %02.0d %%\", (int)humidity); //输出湿度 Serial.println(disp_buf); delay(1000); } ``` ## 硬件连接 ![图 0](../../static/images/docs/diy/picxel clock/dht11/dht11 2024 12 05 23 08 38.png) > 这里其实我是做了电路设计的，如果你发现读取不到数据，可以尝试将模块VDD或者VCC接到开发板的5V看看。 > ![图 1](../../static/images/docs/diy/picxel clock/dht11/dht11 2024 12 05 23 08 44.png) ## 代码验证 代码编写完成之后，将ESP32S3开发板接入电脑下载代码，然后打开串口监视器查看现象。 > 下载步骤请参考👉[RTC时钟驱动](ds1302.html)章节的代码验证小节。 可以看到温湿度数据读取显示正常。 ![图 2](../../static/images/docs/diy/picxel clock/dht11/dht11 2024 12 05 23 09 58.png) >! 说明：如果你根据代码操作运行不起来，可以下载👉[例程](https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/example/dht11)看看"},"/diy/picxel-clock/basic.html":{"title":"ESP32S3像素时钟","content":" title: ESP32S3像素时钟 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 实物展示 ![图 21](../../static/images/docs/diy/picxel clock/basic/basic 2024 12 05 22 14 05.png) ![图 22](../../static/images/docs/diy/picxel clock/basic/basic 2024 12 05 22 14 25.png) ![图 23](../../static/images/docs/diy/picxel clock/basic/basic 2024 12 05 22 14 30.png) ![图 24](../../static/images/docs/diy/picxel clock/basic/basic 2024 12 05 22 14 35.png) ## 介绍 基于立创·ESP32S3R8N8开发板制作的像素时钟。 ## 软件架构 VSCode下的platformIO + arduino环境。 ## 器件清单 1. 1个 ESP32S3R8N8开发板 2. 1个 DHT11温湿度传感器 3. 1个 DS1302时钟模块 4. 1个 8*32大小WS2812彩灯矩阵 5. 1个 MAX4466 运算放大器/音频采集模块 6. 1个 按钮 7. 1个 SU 03T语音识别模块+配套的喇叭和麦克风（咪头） 8. 1个 振动小电机 9. 1个 光敏电阻+1K电阻 ## 硬件连接 <div style \"text align:center;\"> <table style \"margin:auto; width:100%\"> <tr> <td style \"text align:center\"><strong>模块名称</strong></td> <td style \"text align:center\">模块引脚</td> <td style \"text align:center\">ESP32S3R8N8管脚</td> </tr> <tr> <td rowspan \"2\">DS1307</td> <td>SDA</td> <td>3</td> </tr> <tr> <td style \"text align:center\">SCL</td> <td style \"text align:center\">2</td> </tr> <tr> <td>DHT11</td> <td>OUT</td> <td>4</td> </tr> <tr> <td>WS2812</td> <td>DIN</td> <td>8</td> </tr> <tr> <td>MAX4466</td> <td>OUT</td> <td>1</td> </tr> <tr> <td>按钮</td> <td>KEY</td> <td>0</td> </tr> <tr> <td rowspan \"2\">SU 03T语音识别模块</td> <td>B2</td> <td>13</td> </tr> <tr> <td style \"text align:center\">B3</td> <td style \"text align:center\">12</td> </tr> <tr> <td>振动电机（需要三极管驱动）</td> <td>MOTOR</td> <td>11</td> </tr> <tr> <td>光敏电阻（需要1k电阻分压）</td> <td>light</td> <td>5</td> </tr> <tr> <td rowspan \"3\">共用部分</td> <td>3V3(MAX4466, DHT11, 光敏电阻, DS1302)</td> <td>3V3</td> </tr> <tr> <td style \"text align:center\">5V (WS2812, SU 03T, 振动电机)</td> <td style \"text align:center\">5V</td> </tr> <tr> <td style \"text align:center\">GND(全部) </td> <td style \"text align:center\">GND</td> </tr> </table> </div> ## 原理图 **V1.0.1版 原理图** ![图 25](../../static/images/docs/diy/picxel clock/basic/basic 2024 12 05 22 15 00.png) ## 待完善问题 1. 如果天气获取失败，应该显示获取失败。 2. 板子发热，大概是一直开启WIFI的问题。 3. WIFI配网没有好看的HTML界面，进入配网时像素时钟没有UI显示。 4. 亮度自动调节功能与天气界面的今明日切换的渐灭渐亮冲突了 ## 部分代码参考 https://wokwi.com/projects/383363216212925441 https://gitee.com/adamhxx/arduino open source/tree/master/ESP32C3 CLOCK https://github.com/sf122458/ESP32C3 PixelClock https://github.com/pfalcon/uzlib ## 更新时间 > 一次更新时间：2024 4 24 > 二次更新时间：2024 7 28 > 三次更新时间：2024 8 7 新增WIFI配网但是没有添加动画有BUG，配网的HTML界面没有完善 > 四次更新时间：2024 8 8 新增亮度自动调节功能，但是发现与天气界面的今明日切换的渐灭渐亮冲突了，有BUG > 五次更新时间：2024 8 16 新增振动电机功能，初始化完振动一次，按下按键就振动一次。解决配网时会自动连接上一个wifi导致无法配网问题，删除自动连接wifi部分。发现无法进行第二次配网的BUG > 六次更新时间：2024 8 24 新增语音识别功能，语音命令表见main.cpp文件的注释 > 七次更新时间：2024 8 31 新增语音识别例程和教程文档"},"/diy/picxel-clock/weather.html":{"title":"获取天气情况","content":" title: 获取天气情况 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 硬件准备 你只需要有一个ESP32S3开发板。我目前使用的是：立创开发板的立创·ESP32S3R8N8开发板。 > **购买地址：**[立创·ESP32S3R8N8 开发板](https://item.szlcsc.com/22034693.html?fromZone s_s__%2522%25E7%25AB%258B%25E5%2588%259B%25E5%25BC%2580%25E5%258F%2591%25E6%259D%25BF%2522) ## 和风天气API ### 和风天气介绍 > [和⻛天气](https://www.qweather.com/)是中国领先的气象科技服务商、国家高新技术 企业，致力于运用先进气象模型结合大数据、人工智能 技术发展智慧型气象服务。 他们的业务包括气象数据分发、地理信息、气象可视 化、个人气象服务等，在全球10个国家建有数据中心， 为300余家中国及全球企业、50万开发者提供优质的数 据服务。 **另外的话** > 和风天气支持用户免费使用订阅，只是一个用户只能创建一个项目API，但是对我们来说已经足够了，感谢和风天气！ ### 创建自己的天气API 请前往 [和风天气API](https://dev.qweather.com/) 官网，注册账号并进入控制台。 ![图 0](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 51 48.png) 关于和风天气的API介绍和开发文档，参考控制台处的介绍： ![图 2](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 52 04.png) 开始创建属于我们的API ! ![图 1](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 51 58.png) 和风天气项目创建参数填写： ![图 3](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 52 18.png) 完成创建！ ![图 4](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 52 23.png) ### API介绍 和风天气的 [API介绍网页](https://dev.qweather.com/docs/api/) 如下： ![图 5](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 52 33.png) 本文将用的API是``城市天气 > 每日天气预报 > 3天预报API`` 。[【API的详细介绍页点我】](https://dev.qweather.com/docs/api/weather/weather daily forecast/) ![图 6](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 52 38.png) >**需要注意的是，如果是免费订阅，要将API Host更改为 ``devapi.qweather.com``。** 这里以获取深圳``3天的天气预报为例``，关键的API参数说明如下： ```html https://devapi.qweather.com/v7/weather/3d?location 101280601&key YOUR_KEY ``` >请求参数包括必选和可选参数，参数之间使用&进行分隔。这里只给大家介绍必填项。 **1. key(必选)** ： 用户认证key，请参考[如何获取你的KEY](https://dev.qweather.com/docs/configuration/project and key/)。 **2. location(必选)** ： 需要查询地区的[LocationID](https://dev.qweather.com/docs/resource/glossary/#locationid)或以英文逗号分隔的经度,纬度坐标（十进制，最多支持小数点后两位），LocationID可通过GeoAPI获取。例如 location 101010100 或 location 116.41,39.92 关于这个LocationID需要各位自行根据和风天气官方的github地址查询，这里我找到深圳的LocationID为：``101280601`` ![图 7](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 52 56.png) ### 手动验证API是否正确 首先回到你的和风天气管理台。你会看到你新建的项目。 ![图 8](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 53 03.png) 复制你的密钥``KEY``。 ![图 9](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 53 09.png) 然后将你的``KEY``填充到下方API的``YOUR_KEY``中 > 下方这个是获取深圳3天的天气预报API，只剩KEY没有填写 ```html https://devapi.qweather.com/v7/weather/3d?location 101280601&key YOUR_KEY ``` 例如我的KEY是 `ABCasdsdgsdfgdsgdfgdf`，则我的API是 ```heml https://devapi.qweather.com/v7/weather/3d?location 101280601&key ABCasdsdgsdfgdsgdfgdf ``` 填写你的``KEY``后，直接复制该``API``，将它作为网址跳转到对应页面，你就会看的返回的天气数据。 ![图 10](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 53 50.png) 关于API返回的数据具体的意思是什么，参考该[API的介绍页](https://dev.qweather.com/docs/api/weather/weather daily forecast/)。 ![图 11](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 53 57.png) **根据返回的参数说明，这里我关注的是4个数据：** ![图 12](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 54 03.png) 图标代码的说明：返回的数据中关于天气的说明只有空落落的数字，这些数字在API说明中代表着各个天气情况。[数字对应的天气情况链接。](https://dev.qweather.com/docs/resource/icons/) ![图 13](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 54 11.png) 到这里我们就已经是准备好了，接下来可以上工程代码了。请准备好你的``完整API``和``KEY``。 ## 工程创建 在VSCode中打开PlatformIO扩展创建名为`weather`的 `Espressif ESP32 S3 DevKitM 1` 工程。 关于详细图文创建工程的过程请参考👉[RTC时钟驱动](ds1302.html)章节的工程创建小节。 ## 安装驱动库 在驱动库下载界面，搜索``ArduinoJson``，安装来自``Benoit Blanchon`` 的 ``ArduinoJson``库。将该库安装到我们的工程之中。 > 关于详细图文安装驱动库的过程请参考👉[RTC时钟驱动](ds1302.html)章节的安装驱动库小节。 安装完成之后，打开``platformio.ini``文件，应该可以看到已经安装上了驱动库。 ![图 14](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 55 51.png) 这里还有一个问题，和风天气API返回的JSON格式是带了[Gzip压缩](https://dev.qweather.com/docs/best practices/gzip/)的。 为了能够在ESP32S3中进行Gzip的解压操作，引用了github上的一个开源项目，来自``pfalcon``的[uzlib](https://github.com/pfalcon/uzlib)。**感谢伟大的开源贡献者！** ![图 15](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 56 12.png) 在我们的工程中，去``lib``文件夹下新建一个文件夹``uzlib``，将仓库中的 ``src`` 文件夹下的文件全部拉下来保存在我们在工程中新建的``uzlib``文件夹下。 ![图 16](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 56 21.png) ## 编辑代码 在工程中的``src``文件夹下的新建 ``weather.cpp`` 文件。 往 ``weather.cpp`` 中写入如下代码： ```c #include \"weather.h\" Weather::Weather(String apiKey, String location) { this >apiKey apiKey; this >location location; } bool Weather::update() { HTTPClient http; //用于访问网络 WiFiClient *stream; int size; http.begin(\"https://devapi.qweather.com/v7/weather/3d?location \"+ this >location + \"&key \" + this >apiKey); //获取近三天天气信息 int httpcode http.GET(); //发送GET请求 if(httpcode > 0) { if(httpcode HTTP_CODE_OK) { stream http.getStreamPtr(); //读取服务器返回的数据 size http.getSize(); } } else { Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", http.errorToString(httpcode).c_str()); } http.end(); //结束当前连接 uint8_t inbuff[size]; stream >readBytes(inbuff, size); uint8_t *outbuf NULL; uint32_t out_size 0; int result ArduinoUZlib::decompress(inbuff,size, outbuf, out_size); deserializeJson(doc, outbuf); today doc[\"daily\"][0].as<JsonObject>(); tomorrow doc[\"daily\"][1].as<JsonObject>(); return true; } //获取天气数据中的当天最高气温数据 int Weather::getTempMax(bool is_today) { if(is_today) { return today[\"tempMax\"].as<int>(); } else { return tomorrow[\"tempMax\"].as<int>(); } } //获取天气数据中的当天最低气温数据 int Weather::getTempMin(bool is_today) { if(is_today) { return today[\"tempMin\"].as<int>(); } else { return tomorrow[\"tempMin\"].as<int>(); } } //获取天气数据中的天气标识代码 int Weather::getWeather(bool is_today, bool is_day) { if(is_today) { if(is_day) return today[\"iconDay\"].as<int>(); else return today[\"iconNight\"].as<int>(); } else { if(is_day) return tomorrow[\"iconDay\"].as<int>(); else return tomorrow[\"iconNight\"].as<int>(); } } ``` 在工程中的``include``文件夹下的新建 ``weather.h`` 文件。 往 ``weather.h`` 中写入如下代码： ```c #ifndef _WEATHER_H #define _WEATHER_H #include \"Arduino.h\" #include \"ArduinoJson.h\" #include \"ArduinoUZlib.h\" #include \"HTTPClient.h\" //定义天气类 class Weather { public: Weather(String apiKey, String location); bool update(); //发送一次请求信息，获取天气数据 //只需要今明日的天气与温度，故仅设置了以下若干函数 int getTempMax(bool is_today); int getTempMin(bool is_today); int getWeather(bool is_today, bool is_day); private: String apiKey; //天气API密钥 String location; //地点 StaticJsonDocument<2048> doc; //Json容器 JsonObject today, tomorrow; //可根据返回的json信息自行定义其他天气数据 }; #endif ``` 打开工程下的``src``文件夹下的``main.cpp``，并且写入如下代码： ```c #include <Arduino.h> #include <WiFi.h> #include \"weather.h\" //定义Weather类，用于解析Json数据并返回天气数据 //WIFI #define WIFI_SSID \"lckfb\" //要连接的WIFI名称 #define WIFI_PASSWORD \"12345678\" //要连接的WIFI密码 #define WIFI_RETRY_COUNT 20 //WIFI连接重试数 //和风天气预报 #define USER_KEY \"d89d4706adcc4fb89d6f166cb420ee39\" //密钥 #define LOCATION_ID \"101280601\" //地点标识：深圳 int weatherid; //根据和风天气API返回的天气ID显示对应天气 bool is_day 1; //白天为1，夜晚为0 bool is_today 1; //今天为1，明天为0 //创建天气对象 Weather weather(USER_KEY, LOCATION_ID); //根据和风天气API返回天气标识 void WeatherIcon(int weatherid) { switch(weatherid) { case 100://白天晴 Serial.println(\"白天晴\\r\\n\"); break; case 101://多云 case 102://少云 case 151://夜间多云 case 152://夜间少云 case 103://晴间多云 Serial.println(\"多云\\r\\n\"); break; case 104://阴天 Serial.println(\"阴天\\r\\n\"); break; case 150://夜间晴朗 Serial.println(\"夜间晴朗\\r\\n\"); break; case 153://夜间晴间多云 Serial.println(\"夜间多云\\r\\n\"); break; case 305://小雨 case 309://毛毛雨/细雨 Serial.println(\"小雨\\r\\n\"); break; case 300://阵雨 case 350://夜间阵雨 case 306://中雨 case 399://雨 case 313://冻雨 case 314://小到中雨 Serial.println(\"阵雨\\r\\n\"); break; case 301://强阵雨 case 351://夜间强阵雨 case 307://大雨 case 308://极端降雨 case 310://暴雨 case 311://大暴雨 case 312://特大暴雨 case 315://中到大雨 case 316://大到暴雨 case 317://暴雨到大暴雨 case 318://大暴雨到特大暴雨 Serial.println(\"大雨\\r\\n\"); break; case 302://雷阵雨 Serial.println(\"雷阵雨\\r\\n\"); break; case 303://强雷阵雨 Serial.println(\"强雷阵雨\\r\\n\"); break; //雪天 case 400://小雪 case 401://中雪 case 402://大雪 case 403://暴雪 case 404://雨夹雪 case 405://雨雪天气 case 406://阵雨夹雪 case 407://阵雨夹雪 case 408://小到中雪 case 409://中到大雪 case 410://雪 case 456://阵雨夹雪 case 457://阵雪 case 499://雪 Serial.println(\"雪天\\r\\n\"); break; //雾霾 case 500://薄雾 case 501://雾 case 509://浓雾 case 510://强浓雾 case 514://大雾 case 515://特强浓雾 Serial.println(\"雾天\\r\\n\"); break; case 502://霾 case 511://中度霾 case 512://重度霾 case 513://严重霾 Serial.println(\"雾霾\\r\\n\"); break; } } void setup() { int count 0; char disp_buf[50] {0}; //串口初始化 Serial.begin(9600); //尝试连接WIFI网络 WiFi.begin(WIFI_SSID, WIFI_PASSWORD); //尝试连接直至超时 while (WiFi.status() ! WL_CONNECTED) { count++; if (count > WIFI_RETRY_COUNT) { Serial.println(\"\\r\\nconnection failed.\\r\\n\"); break; } delay(500); Serial.print(\".\"); } //获取天气数据 weather.update(); //WIFI断开连接 WiFi.disconnect(); //显示最低与最高温度 sprintf(disp_buf, \"TempMin %d\", weather.getTempMin(is_today)); Serial.println(disp_buf); sprintf(disp_buf, \"TempMax %d\", weather.getTempMax(is_today)); Serial.println(disp_buf); //显示天气标识代码 sprintf(disp_buf, \"WeatherCode %d\", weather.getWeather(is_today, is_day)); Serial.println(disp_buf); //根据天气标识代码确定天气 WeatherIcon(weather.getWeather(is_today, is_day)); } void loop() { delay(1000); } ``` ## 代码验证 代码编写完成之后，将ESP32S3开发板接入电脑下载代码，然后打开串口监视器查看现象。 > 下载步骤请参考👉[RTC时钟驱动](ds1302.html)章节的代码验证小节。 实际获取天气数据的效果如下： 最低温度26，最高温度31，天气代码为307，对应的就是大雨。 ![图 17](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 57 17.png) 查看和风天气的API中[天气代码说明](https://dev.qweather.com/docs/resource/icons/)，确认数据是正确的。 ![图 18](../../static/images/docs/diy/picxel clock/weather/weather 2024 12 05 23 57 22.png) >! 说明：如果你根据代码操作运行不起来，可以下载👉[例程](https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/example/weather)看看"},"/diy/picxel-clock/ds1302.html":{"title":"本地时钟读取与显示","content":" title: 本地时钟读取与显示 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 工程创建 在VSCode中打开PlatformIO扩展创建工程。 ![图 0](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 53 19.png) 设置工程向导 ![图 1](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 53 26.png) ![图 2](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 53 32.png) 等待创建完成。 ![图 3](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 53 37.png) ## 安装驱动库 创建完成之后，我们在VSCode中打开我们刚才创建的工程文件夹。 ![图 4](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 53 42.png) 在VSCode中回到PlatformIO的主页，给工程安装DS1302的驱动库。 ![图 5](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 54 05.png) ![图 6](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 54 09.png) 搜索DS1302，安装l来自``Rafa Couto``的``Ds1302``库。 ![图 7](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 54 14.png) 将库安装到我们的工程中。 ![图 8](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 54 19.png) ![图 9](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 54 29.png) 打开``platformio.ini``文件，可以看到已经安装上了DS1302的驱动库。 ![图 10](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 54 35.png) ## 编辑代码 打开工程下的``src``文件夹下的``main.cpp``。 输入以下代码： ```C #include <Arduino.h> #include <Ds1302.h> //计时模块DS1302相关定义 #define RST 10 //ds1302的RST引脚定义 #define DATA 3 //ds1302的DATA引脚定义 #define CLK 2 //ds1302的CLK引脚定义 Ds1302 rtc(RST, CLK, DATA); //创建DS1302这个对象 void setup() { //初始化串口 Serial.begin(9600); //初始化DS1302 rtc.init(); //测试时钟是否停止并设置一个日期时间来启动它 if (rtc.isHalted()) { Serial.println(\"RTC is halted. Setting time...\"); //创建基于DS1302库下的时间参数 Ds1302::DateTime dt { .year 24, .month Ds1302::MONTH_JUL, .day 27, .hour 14, .minute 13, .second 0, .dow Ds1302::DOW_SAT }; //将设置的时间写入DS1302模块 rtc.setDateTime(&dt); } else { Serial.println(\"RTC is busy.\\r\\n\"); } Serial.println(\"Time start.\\r\\n\"); } void loop() { char outputString[100] {0}; Ds1302::DateTime now; //获取当前时间并且存储在now中 rtc.getDateTime(&now); static uint8_t last_second 0; //如果秒数发生更新 if (last_second ! now.second) { //手动更新秒数，方便下次判断 last_second now.second; //格式化字符串 sprintf(outputString, \"%d %d %d %d %d:%d:%d\\r\\n\", now.year+2000, now.month, now.day, now.dow, now.hour, now.minute, now.second ); //输出字符串 Serial.println(outputString); } delay(1000); } ``` ## 硬件连接 ![图 11](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 55 19.png) > 这里其实我是做了电路设计的，如果你的模块上没有RST的话应该是不用连接RST引脚的。 > ![图 12](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 55 34.png) ## 代码验证 代码编写完成之后，将**ESP32S3开发板**接入电脑。我当前的开发板上是**CH340K**的驱动，故我这里选择**COM3端口**。 ![图 13](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 56 05.png) 编译并下载到开发板中。 ![图 14](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 56 11.png) 点击打开串口监视器。 ![图 15](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 56 16.png) 可以看到开发板可以正常的读取和设置DS1302的时间。输出正常。 ![图 16](../../static/images/docs/diy/picxel clock/ds1302/ds1302 2024 12 05 22 56 21.png) >! 说明：如果你根据代码操作运行不起来，可以下载👉[例程](https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/example/ds1302)看看"},"/diy/index.html":{"title":"DIY项目合集","content":" title: DIY项目合集 keywords: keyword1, keyword2 desc: description for this article date: 2024 12 07 ## 物联网像素时钟 基于立创·ESP32S3R8N8开发板制作的像素时钟，包含网络时钟、天气显示、温湿度显示、黑客帝国数字雨特效、音律拾音灯等功能。 开发方式：VSCode下的platformIO + arduino环境。 ![图 0](../../static/images/docs/diy/README/README 2024 12 06 00 38 54.png) ## 天猛星平衡车 基于立创·天猛星MSPM0G3507开发板制作的小平衡车。 > MSPM0G3507为TI德州仪器制作的ARM 32位 Cortex M0+ CPU。最高80MHz,128K FLASH + 32K SRAM. ![图 1](../../static/images/docs/diy/README/README 2024 12 06 00 51 20.jpg) ## 个人WIKI网站搭建 基于开源的teedoc框架搭建的个人WIKI资料记录网站。 ![图 2](../../static/images/docs/diy/README/README 2024 12 06 01 00 55.png) ## 年轻人的第一台舰防炮 K230 AI视觉识别开发板 + 电动玩具枪 组成的目标自动跟踪炮台。 ## WIFI图传小车 基于嘉立创EDA和ESP32S3R8N8开发板设计的WIFI图传小车。通过ESP32S3自带的WIFI功能，将OV2640摄像头采集的图像数据通过WIFI进行10米左右的图传。 ## 电子物料收纳盒"},"/diy/tracking-cannon/basic.html":{"title":"舰防炮介绍","content":" title: 舰防炮介绍 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 date: 2025 06 27 author: 老怪鸽 version: 1.0.2 content: 更新了PID和滤波章节 ## 项目背景 项目参考来源： **【给玩具枪加装云台和人脸识别功能，实现目标自动识别锁定功能】 ** <iframe src \"//player.bilibili.com/player.html?isOutside true&aid 986378786&bvid BV1at4y1c7kt&cid 858044263&p 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"width:43vw;height:34vw;min width: 85%;\"></iframe> 原作者是采用的 `opencv` 作为识别方案，而 `opencv` 需要运行在电脑的操作系统上，不是很方便。而最近正好看到立创开发板的 `K230 AI` 开发板在找内测，有幸联系到并且参与其中。 将决定以 `K230` 为主要核心，控制二维舵机云台作为`运动装置`、板载摄像头识别物品功能作为`瞄准装置`、电动玩具枪作为`发射装置`等，以实现自动追踪炮台的功能。 ## 硬件设计 ### 硬件准备 1. **二维舵机云台** ![图 3](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 22 32 10.png) 地址：https://item.taobao.com/item.htm?_u l2t4uge5db1c&id 560120308139 2. **电动玩具枪** ![图 2](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 22 31 08.png) 地址：https://item.taobao.com/item.htm?_u l2t4uge530d9&id 684699922229 3. **K230 AI识别开发板** ![图 0](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 22 29 03.png) 地址：https://lckfb.com/project/detail/lckfb lspi k230 1g canmv?param baseInfo 4. **辅助工具** 螺丝批套装、热胶枪、杜邦线等。 ### 硬件连接 ![图 4](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 22 54 53.png) 电动玩具枪也是可以通过开关控制的，只需要通过继电器的方式，连接到GPIO上是可以控制开枪的，这里我因为没有买继电器所以我就先不画。 .. details::K230排针接口示意图，点击展开 ![图 5](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 22 57 24.png) ## 软件设计 K230的快速入门请参考：https://wiki.lckfb.com/zh hans/lushan pi k230/quick start.html 请按照上面的链接，完成开发板的组装、`CanMV` 固件烧录、电脑连接等操作。我在后面将不会介绍什么是 `IDE` ，以及如何连接。 ### IDE显示图像 显示图像在K230的固件中一共支持4种，分别是 `HDMI` 的 `VGA` ， `HDMI` 的 `1080P` 、`LCD`、`IDE` 等。我们先了解怎么将摄像头采集到的画面显示在 `IDE` 的**图像缓冲区**。 根据 `K230` 资料的[Sensor例程讲解](https://developer.canaan creative.com/k230_canmv/dev/zh/example/media/sensor.html) ，提取出 **摄像头的初始化** `+` **采集图像的代码**。 ```py # Camera 示例 import time import os import sys from media.sensor import * from media.display import * from media.media import * DETECT_WIDTH 640 DETECT_HEIGHT 480 sensor None try: # 配置摄像头的图像大小 sensor Sensor(width DETECT_WIDTH, height DETECT_HEIGHT) # 摄像头传感器复位 sensor.reset() # 设置图像是否镜像 # sensor.set_hmirror(False) # 设置图像是否翻转 # sensor.set_vflip(False) # 设置通道0的图像输出尺寸 sensor.set_framesize(width DETECT_WIDTH, height DETECT_HEIGHT) #设置通道0输出格式为RGB565（彩色图像） sensor.set_pixformat(Sensor.RGB565) # Init媒体管理器 MediaManager.init() # 传感器启动运行 sensor.run() while True: sensor.snapshot() #获取一帧图像 except KeyboardInterrupt as e: print(f\"user stop\") except BaseException as e: print(f\"Exception '{e}'\") finally: # sensor stop run if isinstance(sensor, Sensor): sensor.stop() os.exitpoint(os.EXITPOINT_ENABLE_SLEEP) time.sleep_ms(100) # release media buffer MediaManager.deinit() ``` 根据[Display例程讲解](https://developer.canaan creative.com/k230_canmv/dev/zh/example/media/display.html)，提取出将**图像显示到 `IDE` 上的代码**。 ```python import time, os, gc, sys, math from media.sensor import * from media.display import * from media.media import * DETECT_WIDTH 640 DETECT_HEIGHT 480 try: #配置图像显示方式为IDE显示，显示的宽高为DETECT_WIDTH+DETECT_HEIGHT，帧率100fps Display.init(Display.VIRT, width DETECT_WIDTH, height DETECT_HEIGHT, fps 100) while True: Display.show_image(img) #显示一个图像，这个img是摄像头采集的一帧图像 except KeyboardInterrupt as e: print(f\"user stop\") except BaseException as e: print(f\"Exception '{e}'\") finally: # 清除显示缓存 Display.deinit() os.exitpoint(os.EXITPOINT_ENABLE_SLEEP) time.sleep_ms(100) ``` 将这两个代码一整合，就得到了将图像显示到 `IDE` 中的代码： ```python import time import os import sys from media.sensor import * from media.display import * from media.media import * DETECT_WIDTH 640 DETECT_HEIGHT 480 sensor None try: # 配置摄像头的图像大小 sensor Sensor(width DETECT_WIDTH, height DETECT_HEIGHT) # 摄像头传感器复位 sensor.reset() # 设置图像是否镜像 # sensor.set_hmirror(False) # 设置图像是否翻转 # sensor.set_vflip(False) # 设置通道0的图像输出尺寸 sensor.set_framesize(width DETECT_WIDTH, height DETECT_HEIGHT) #设置通道0输出格式为RGB565（彩色图像） sensor.set_pixformat(Sensor.RGB565) #配置图像显示方式为IDE显示，显示的宽高为DETECT_WIDTH+DETECT_HEIGHT，帧率100fps Display.init(Display.VIRT, width DETECT_WIDTH, height DETECT_HEIGHT, fps 100) # Init媒体管理器 MediaManager.init() # 传感器启动运行 sensor.run() while True: img sensor.snapshot() #获取一帧图像 Display.show_image(img) #显示摄像头采集的图像 except KeyboardInterrupt as e: print(f\"user stop\") except BaseException as e: print(f\"Exception '{e}'\") finally: # sensor stop run if isinstance(sensor, Sensor): sensor.stop() # deinit display Display.deinit() os.exitpoint(os.EXITPOINT_ENABLE_SLEEP) time.sleep_ms(100) # release media buffer MediaManager.deinit() ``` 大家可以运行上面的例程看看，在 `CanMV IDE` 中会不会显示出K230开发板摄像头的画面。 ### 颜色识别 K230是一个AI视觉芯片，根据官网资料可以知道，其可以通过摄像头识别出很多东西，比如人脸、形状、颜色、物品、水果等等，这里我比较熟练使用的是**颜色识别**，就先以颜色识别为例，获取指定颜色的目标方位。 而我们能够获取颜色的方位，那就可以根据官方例程推举出识别其他东西时，怎么获取对应识别目标的方位了。 根据 `canMV K230 IDE` 自带的颜色识别例程，整理出关键的代码。 以下是颜色识别例程： ```python # Find Blobs Example # # This example shows off how to find blobs in the image. import time, os, gc, sys from media.sensor import * from media.display import * from media.media import * DETECT_WIDTH ALIGN_UP(320, 16) DETECT_HEIGHT 240 sensor None def camera_init(): global sensor # construct a Sensor object with default configure sensor Sensor(width DETECT_WIDTH,height DETECT_HEIGHT) # sensor reset sensor.reset() # set hmirror # sensor.set_hmirror(False) # sensor vflip # sensor.set_vflip(False) # set chn0 output size sensor.set_framesize(width DETECT_WIDTH,height DETECT_HEIGHT) # set chn0 output format sensor.set_pixformat(Sensor.RGB565) # use IDE as display output Display.init(Display.VIRT, width DETECT_WIDTH, height DETECT_HEIGHT,fps 100,to_ide True) # init media manager MediaManager.init() # sensor start run sensor.run() def camera_deinit(): global sensor # sensor stop run sensor.stop() # deinit display Display.deinit() # sleep os.exitpoint(os.EXITPOINT_ENABLE_SLEEP) time.sleep_ms(100) # release media buffer MediaManager.deinit() def capture_picture(): fps time.clock() while True: fps.tick() try: os.exitpoint() global sensor img sensor.snapshot()#获取图像 # 设置颜色阈值 thresholds [[0, 80, 40, 80, 10, 80]] # 红色的阈值，这样代码就只识别红色 # 从图像中查找颜色，根据阈值进行对比，当阈值一致时，将对应颜色的各个参数/位置等保存到blobs变量中 blobs img.find_blobs(thresholds ,pixels_threshold 500) # 从blobs中遍历各个被识别到的阈值一样的颜色，将遍历到的颜色参数赋值给blob for blob in blobs: # 调用画矩形API，填入遍历到的颜色4个角的位置，设置矩形框的颜色为RGB的RG全色 img.draw_rectangle(blob[0], blob[1], blob[2], blob[3], color (255, 255, 0)) # 显示图像 Display.show_image(img) img None gc.collect() print(fps.fps()) #输出帧率 except KeyboardInterrupt as e: print(\"user stop: \", e) break except BaseException as e: print(f\"Exception {e}\") break def main(): os.exitpoint(os.EXITPOINT_ENABLE) camera_is_init False try: print(\"camera init\") camera_init() camera_is_init True print(\"camera capture\") capture_picture() except Exception as e: print(f\"Exception {e}\") finally: if camera_is_init: print(\"camera deinit\") camera_deinit() if __name__ \"__main__\": main() ``` **分析：** 其实主要就是 [find_blobs](https://developer.canaan creative.com/k230_canmv/dev/zh/api/openmv/image.html#find blobs) `API`，它会去图像中查找我们设置的阈值的颜色，找到 一个就记录起来成为一个对象，找到一个就记一个，然后我们就可以对该颜色对象为所欲为了。 但是这个例程还是有一点问题，也不能说是问题，只是不符合我们的要求，我们的要求是只识别一个颜色。毕竟我们只有一个炮台，识别再多个也只能打一个。那么问题来了，这个例程是会将图像中识别到的颜色都画框并记录，类似以下现象：（识别浅蓝色） ![图 6](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 23 09 37.png) 图中的白色矩形框+白色十字就是表示的识别到的颜色。现在识别出了那么多个目标，我们只有一个炮口怎么办？**我们可以优先找到最大的，最近的一个开炮！**而在图像的世界里，在多个目标中，像素越多的，说明离摄像头越近！那就是最大的目标！ 以下是在一堆识别到的图像中，找到最大像素的图像代码：**(只写关键的了)** ```python # 拍摄一张图片 img sensor.snapshot() # 查找图像中满足红色阈值（red_threshold）的区域 blobs img.find_blobs([red_threshold], pixels_threshold 200, area_threshold 200, merge True) # 如果找到了至少一个blob if blobs: # 从blobs中找到最大像素点的blob largest_blob max(blobs, key lambda b: b.pixels()) # 只对最大像素点的目标画框，框的颜色是RGB中的R（红色） img.draw_rectangle(largest_blob.rect(), color (255, 0, 0)) # 在框内画十字，标记中心点 img.draw_cross(largest_blob.cx(), largest_blob.cy(), color (255, 0, 0)) # 将位置和宽高格式化为字符串 wz \"x {}, y {}, w {}, h {}\".format(x_offset, y_offset, largest_blob.w(), largest_blob.h()) # 图像上显示位置和宽高信息的字符串，字符的大小是32 img.draw_string_advanced(0,0,32,wz) ``` > 上面代码中的阈值注释虽然是红色阈值，但是我实际上用的是绿色的阈值 现在我们就已经完成了目标定位的任务了，上面的代码中找到了最大像素的目标，并且输出它对于摄像头图像大小的X轴Y轴位置。 ![图 7](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 23 09 46.png) 我还加了一些辅助内容，比如给图像的中心画一个绿色的十字。其他内容具体看源码 `main.py`。 ### 舵机控制 舵机控制的基本原理，参考该博主的文章：[舵机篇（一）舵机原理](https://blog.csdn.net/weixin_38288325/article/details/132366604?fromshare blogdetail&sharetype blogdetail&sharerId 132366604&sharerefer PC&sharesource qq_51930953&sharefrom from_link) 舵机控制简单来说，就是输入一个20ms周期的PWM给他，通过调整高电平占空比实现舵机的旋转。 > 频率等于周期的倒数，所以 `20ms` 周期 `1 / 20` `50 Hz` 频率 在庐山派K230开发板引出的PWM中，PWM只有5个，分别是PWM0~PWM4。只有特定的引脚支持PWM功能，具体见下图： ![图 5](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 22 57 24.png) 在我们的舵机案例中，使用的是 `GPIO46` 、 `GPIO47` 上的，`PWM2` 和 `PWM3`。 在代码中初始化PWM参数如果下： > 配置方法具体说明，请参考立创开发板wiki：[庐山派开发板资料 PWM](https://wiki.lckfb.com/zh hans/lushan pi k230/basic/pwm.html) ```python from machine import PWM, FPIOA, Pin # 配置排针引脚号12，芯片引脚号为47的排针复用为PWM通道3输出 pwm_io1 FPIOA() pwm_io1.set_function(47, FPIOA.PWM3) # 初始化PWM参数 pwm_ud PWM(3, 50, 50, enable True) # 默认频率50Hz,占空比50% 3~12 # 配置排针引脚号32，芯片引脚号为46的排针复用为PWM通道2输出 pwm_io2 FPIOA() pwm_io2.set_function(46, FPIOA.PWM2) # 初始化PWM参数 pwm_lr PWM(2, 50, 50, enable True) # 默认频率50Hz,占空比50% 2~13 pwm_lr.duty(7.5) #旋转到中间 pwm_ud.duty(7.7) #旋转到中间 ``` 在案例中，我将左右旋转的舵机命名为 `pwm_lr` ，上下旋转的舵机命名为 `pwm_ud` 。 在上面的案例中还有一个地方需要说明，我为了让舵机一上电就默认旋转到中间，设置了两个舵机动作： ```python pwm_lr.duty(7.5) #旋转到中间 pwm_ud.duty(7.7) #旋转到中间 ``` 这里的 `7.5` 指的是占空比的百分比，即7.5%的高电平占空比。我们来求一下，为什么7.5是中间。我们现在知道了以下参数： * PWM周期为 `20 ms` * PWM频率为 `50 Hz` * 高电平的占空比为 `7.5%` 求我们当前旋转的角度。 根据180度旋转的舵机控制原理，可以知道舵机旋转角度和周期的关系如下图： ![图 8](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 21 23 39 34.png) 我们只要控制在20ms的周期内的高电平时间，就可以控制舵机的旋转角度。 那么获取高电平时间公式如下： <center> 高电平时间 PWM周期 × 占空比 </center> 参照之前的参数 带入得到： <center> 高电平时间 20 ms × 0.075（7.5%） </center> 高电平的时间是 `1.5` 毫秒 。 而 `1.5 ms` 就是控制舵机旋转到0度。所以代码中设置 `7.5%` 的占空比就是让舵机旋转到中间（舵机最左是 90度，中间是0度，最右是90度）。 而上下旋转的舵机占空比，我设置为了7.7%，这个是我的测试值，测试出来的舵机旋转比较接近中间的值，大家自行测试。 现在180度的舵机，我们将其分成为 ` 90~90度` 的范围。我们还要知道3个参数： 1. 最大角度 `90度` 时我们要设置多少占空比； 2. 最小角度 ` 90度` 时我们要设置多少占空比； 3. 中间角度 `0度` 时我们要设置多少占空比； 经过我自己实测，上下动作的舵机占空比范围是 `2.5~12.5%` 的占空比，`2.5% `占空比时角度最小，`12.5%` 占空比时角度最大，`7.5%` 占空比时角度居中。 > **为什么不直接用理论值计算？而是要手动测试呢？** > 这个是因为舵机云台结构的原因，比如上下旋转的舵机我们设置旋转为了0度，但是因为结构上的原因，舵机转不到0度，它被结构框体卡死了，这个就是赌死现象：没有转到0度，舵机就一直转。 > 为了防止堵死的现象出现，就需要我们手动测试一个安全的旋转范围。 这里以Y轴举例(Y轴就是上下旋转的舵机)，现在Y轴的范围在摄像头采集的图像中是 `0 ~ 479` 个像素，屏幕的中心值就是 `480/2 240` ，而Y轴的范围是从 `0` 开始的，所以我们得减一，屏幕的中心值就是 `239` 。我们以屏幕中心为参考， **当Y轴的值小于239时**，我们就判断识别物体是上方； **当Y轴的值大于239时**，我们就判断识别物体是下方； **当Y轴的值等于239时**，我们就判断识别的物体是Y轴中心； ![图 9](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 22 00 00 10.png) 我个人觉得全部是正数的范围，不方便我们去处理舵机，0 ~ 238是上方，239是中间，240 ~ 379是下方，这样不好带入到我们后面的舵机控制中。为了更加方便我自己，我将其Y轴范围修改如下： 数值范围 说明 : : : : 239~0 上方 0 中间 0~239 下方 这样分布后我们就知道负数是上，正数是下，我们要让舵机尽量往中间（就是0的位置）移动。 实现的代码： > 实现了X轴和Y轴距离中心的位置反馈 ```python # 如果找到了至少一个blob if blobs: # 找到最大的blob largest_blob max(blobs, key lambda b: b.pixels()) # 画框 img.draw_rectangle(largest_blob.rect(), color (255, 0, 0)) # 在框内画十字，标记中心点 img.draw_cross(largest_blob.cx(), largest_blob.cy(), color (255, 0, 0)) # 计算相对于屏幕中心的X轴和Y轴的偏移量 x_offset largest_blob.cx() img.width() // 2 y_offset largest_blob.cy() img.height() // 2 # 屏幕显示位置信息和像素大小，包含正负号 wz \"x {}, y {}, w {}, h {}\".format(x_offset, y_offset, largest_blob.w(), largest_blob.h()) img.draw_string_advanced(0,0,32,wz) ``` >! **接下来我们来考虑一个问题：如何将Y轴的数值反馈给舵机让它按照我们设置的方向动作？** 接下来了解一下我的想法，我们要让舵机往Y轴的中心 0 去动作。 当识别物体Y轴为 239 ~ 0时，我们让舵机向下，直到识别物体Y轴的数值为0； 当识别物体Y轴为0 ~ 239 时，我们让舵机向上，直到识别物体Y轴的数值为0； **现在这个Y轴就是舵机角度与目标方位的误差！我们要让误差尽量保持为0！** 首先是考虑如何解决数值不对等问题。舵机的范围是 `2.5 ~ 12.5`，Y轴的范围是 ` 239 ~ +239` ，我们要将Y轴的数值压缩到 `2.5 ~ 12.5` 的范围。可以通过以下代码实现： ```python # DETECT_WIDTH 640 # DETECT_HEIGHT 480 # min_duty 2.5 #最小占空比 # max_duty 12.5 #最大占空比 ## 将Y轴偏移数值转换为占空比的函数 def input_to_duty_cycle(input_min, input_max, input_value): # 定义输入输出范围 # input_min (DETECT_HEIGHT // 2) # input_max (DETECT_HEIGHT // 2) output_min min_duty output_max max_duty # 检查输入是否越界 if input_value < input_min or input_value > input_max: raise ValueError(f\"输入值必须在 {input_min} 和 {input_max} 之间\") # 计算线性映射公式 slope (output_max output_min) / (input_max input_min) output_value output_min + (input_value input_min) * slope return output_value ``` 现在解决了这个数值不对等问题，舵机的居中角度是 `7.5`，当识别物体在上方时，舵机的数值输出小于 `7.5` ; 当识别物体在下方时，舵机的数值输出大于7.5; 完整代码： ```python import time, os, gc, sys, math,utime from machine import PWM, FPIOA, Pin, UART from media.sensor import * from media.display import * from media.media import * from pid import PID DETECT_WIDTH 640 DETECT_HEIGHT 480 sensor None ###############################舵机配置##################################################### # 2.5 90度 7.5 0度 12.5 90度 min_duty 2.5 #最小占空比 max_duty 12.5 #最大占空比 mid_duty 7.5 # 中间值，对应于0度 pwm_lr None # 配置排针引脚号12，芯片引脚号为47的排针复用为PWM通道3输出 pwm_io1 FPIOA() pwm_io1.set_function(47, FPIOA.PWM3) # 初始化PWM参数 pwm_ud PWM(3, 50, 50, enable True) # 默认频率50Hz,占空比50% 3~12 # 配置排针引脚号32，芯片引脚号为46的排针复用为PWM通道2输出 pwm_io2 FPIOA() pwm_io2.set_function(46, FPIOA.PWM2) # 初始化PWM参数 pwm_lr PWM(2, 50, 50, enable True) # 默认频率50Hz,占空比50% 2~13 pwm_lr.duty(7.5) #旋转到中间 pwm_ud.duty(7.7) #旋转到中间 ########################################################################################## ## 将Y轴偏移数值转换为占空比的函数 def input_to_duty_cycle(input_min, input_max, input_value): # 定义输入输出范围 # input_min (DETECT_HEIGHT // 2) # input_max (DETECT_HEIGHT // 2) output_min min_duty output_max max_duty # 检查输入是否越界 if input_value < input_min or input_value > input_max: raise ValueError(f\"输入值必须在 {input_min} 和 {input_max} 之间\") # 计算线性映射公式 slope (output_max output_min) / (input_max input_min) output_value output_min + (input_value input_min) * slope return output_value try: # 初始化摄像头 sensor Sensor(width DETECT_WIDTH, height DETECT_HEIGHT) # 传感器复位 sensor.reset() # 开启镜像 sensor.set_hmirror(True)#False # sensor vflip sensor.set_vflip(True)#False True # 设置图像一帧的大小 sensor.set_framesize(width DETECT_WIDTH, height DETECT_HEIGHT) # 设置图像输出格式为彩色的RGB565 sensor.set_pixformat(Sensor.RGB565) # 使用IDE显示图像 Display.init(Display.VIRT, width DETECT_WIDTH, height DETECT_HEIGHT, fps 100) # 初始化媒体管理器 MediaManager.init() # 摄像头传感器开启运行 sensor.run() # 定义要识别颜色的阈值，这里需要根据你的具体情况调整 # 你可以通过尝试不同的阈值来找到最适合你的物体颜色值 red_threshold (0, 42, 17, 94, 6, 50) while True: # 拍摄一张图片 img sensor.snapshot() # 查找图像中满足红色阈值的区域 blobs img.find_blobs([red_threshold], pixels_threshold 200, area_threshold 200, merge True) # 如果找到了至少一个blob if blobs: # 找到最大的blob largest_blob max(blobs, key lambda b: b.pixels()) # 画框 img.draw_rectangle(largest_blob.rect(), color (255, 0, 0)) # 在框内画十字，标记中心点 img.draw_cross(largest_blob.cx(), largest_blob.cy(), color (255, 0, 0)) # 计算相对于屏幕中心的X轴和Y轴的偏移量 x_offset largest_blob.cx() img.width() // 2 y_offset largest_blob.cy() img.height() // 2 # 屏幕显示位置信息和像素大小，包含正负号 wz \"x {}, y {}, w {}, h {}\".format(x_offset, y_offset, largest_blob.w(), largest_blob.h()) img.draw_string_advanced(0,0,32,wz) duty_ud_value input_to_duty_cycle( (DETECT_HEIGHT // 2), (DETECT_HEIGHT // 2), y_offset) print(duty_ud_value) # 中心画十字 img.draw_cross(img.width() // 2, img.height() // 2, color (0, 255, 0), size 10, thickness 3) # IDE显示图片 Display.show_image(img) except KeyboardInterrupt as e: print(f\"user stop\") except BaseException as e: print(f\"Exception {e}\") finally: # sensor stop run if isinstance(sensor, Sensor): sensor.stop() # deinit display Display.deinit() if isinstance(pwm_lr, PWM): pwm_lr.deinit() # release media buffer MediaManager.deinit() os.exitpoint(os.EXITPOINT_ENABLE_SLEEP) time.sleep_ms(100) ``` ![图 9](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 22 53 07.gif) 如果我们将摄像头固定在舵机上，舵机移动的时候，我们的摄像头也移动。那按照想法就是屏幕跟舵机一起动，这样就能够稳定的固定到中心，实现了识别瞄准功能。 将这个代码直接应用到舵机上的效果: GIF动图（没有PID的直接控制） ![图 15](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 03 47.gif) ### PID自动控制 大家根据上面的舵机控制章节，应该是可以实现最简单的舵机追踪功能，但是大家会发现有不稳定或者抖动的现象，比如我举一些例子： 1. 当识别目标快速运动时，舵机的运动速度不会跟着识别目标的速度而进行变化，一直保持一个速度； 2. 超调现象。误差已经到0了，但是因为舵机的旋转惯性，（假设的，实际的舵机速度一直不变惯性很小）导致会超出0误差，比如 1 > 0 > 1，因为惯性从0到1了，又从 1 > 0 > 1，导致怎么都不能正常的误差为0，舵机一直抖。 这个时候我们就要了解一个最常用的控制算法：**PID算法**。 #### PID介绍 PID控制器，即比例 积分 微分控制器，是一种广泛应用于工业控制系统中的**反馈回路控制器**。它通过控制系统的偏差（设定值与实际值之间的差）来调节控制变量，使得系统达到或维持在一个预定的状态。PID控制器由三个基本控制动作组成：`比例（Proportional）`、`积分（Integral）` 和 `微分（Derivative）` ，下面详细介绍这三个部分： **比例（P）控制** 比例控制的作用是根据设定值与实际值之间的误差（e），进行比例放大后作为控制输出。其数学表达式为： <center> P Kp * e </center> 其中，`Kp` 是比例增益，决定了比例控制的强度。比例控制的特点是动作快速直接，**但通常会存在一个稳态误差，即系统稳定后，输出值与设定值之间仍会有一定的差距。** .. details::误差的说明，点击展开 根据设定值与实际值之间的误差（e），应该很好理解 ，我们之前的舵机控制章节就说明了误差的概念，尽可能的让误差为0。 实际值就是摄像头识别物体的方位； 设定值就是摄像头采集的图像中心； 我们要让图像中心接近物体方位。让它们的误差越来越小，直到为0。 .. details::稳态误差的说明，点击展开 即系统稳定后，输出值与设定值之间仍会有一定的差距。就是误差值明明是0了，但是实际上却是在1~2之间徘徊，就是到不了0。 **积分（I）控制** 积分控制的作用是对偏差进行积分运算，**以消除稳态误差**。积分作用考虑了误差的历史累积，其数学表达式为 <center> ![图 12](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 22 00 35 56.png) </center> > 你也可以这么看这个参数：I Ki * e的历史累积 其中，`Ki` 是积分增益。积分控制能够消除稳态误差，**但可能会引起系统的响应速度变慢，并且可能造成系统的超调和振荡。** .. details::超调和振荡的说明，点击展开 \t**超调** 意味着系统输出超过了设定值，比如你的舵机值设定范围是`2.5~12.5%` ，但是PID计算的结果超过了12.5，变成15？20？100？或者更高，这个是严重的问题； **振荡** 则是指系统在设定值附近反复波动，就是猛过头了，反应过激，刹车不了。 **微分（D）控制** 微分控制的作用是根据误差变化的速率（即偏差的微分）来进行控制，以预测误差的未来趋势。微分作用的数学表达式为： <center> ![图 11](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 22 00 35 06.png) </center> 其中，`Kd` 是微分增益。微分控制有助于减少系统的超调和振荡，提高系统的动态性能，**但它对噪声敏感，可能会放大控制信号中的噪声。** .. details::噪声的说明，点击展开 噪声就是干扰，我们用电机速度PID做一个例子，当前我们速度为0，我们设置目标速度为10，通过PID的计算，电机旋转速度会逐渐接近10，这个时候你去手动干预它，让电机不能转，这个就是干扰，你干扰了电机的运动，电机的速度变慢了，导致PID的误差在时间上一直越来越大，那么PID为了让电机速度更快接近目标，PID计算的值就越来越大，电机的旋转力度就越来越大，直到挣脱你的束缚。那对噪声敏感，表示的就是你干扰了一下，PID就崩溃了，对噪声产生过大的反应，导致控制输出不稳定。 **PID控制器的基本形式** 将上述三个控制作用结合起来，PID控制器的理论基本形式可以表示为： <center> ![图 13](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 22 00 37 48.png) </center> 其中 `u(t)` 是控制器的输出，`e(t)` 是在时间t时的偏差。通过PID我们就能够让舵机动作的更加快速，稳定的到达我们设置的目标位置。 #### PID公式转为代码 上面的原理部分大家看看就可以了，我们从实际应用入手。首先将以上PID数学公式转化为代码公式： ```python out (Kp * p) + (Ki * i) + (Kd * d) ``` 整理参数，参数分为静态参数和动态参数： ```python #静态参数 Kp 0 Ki 0 Kd 0 #动态参数 i 0\t\t\t#积分I e 0\t\t\t#当前误差 last_e 0\t\t#之前误差 max_out 0\t\t#最大输出 ``` 将代码公式一一拆分，得到下面的PID的计算函数： ```PYTHON def pid_calc(reference, feedback):#reference 目标位置\tfeedback 当前位置 last_e e #更新之前的误差 e reference feedback #通过当前值和目标值计算获取新的误差 #计算比例P p e * Kp #计算积分I i + e * Ki #计算微分D d (e last_e) * Kd #计算PID输出 out p + i + d #输出限制 if out > max_out: out max_out elif out < max_out: out max_out return out ``` > ! 注意，PID计算是要实时的，请确保PID的计算不会被阻塞太久；积分`I`是累加的，必须是全局变量； 现在PID部分的代码基本完成了，接下来是最重要的如何使用PID。我将PID的代码给封装成为了一个库文件上传到K230里面。 ```python class PID: def __init__(self, kp, ki, kd, maxI, maxOut): #静态参数 self.kp kp self.ki ki self.kd kd #动态参数 self.change_p 0 self.change_i 0 self.change_d 0 self.max_change_i maxI #积分限幅 self.maxOutput maxOut #输出限幅 self.error_sum 0 #当前误差 self.last_error 0 #之前误差 def change_zero(self):#PID变化累计的参数清零 self.change_p 0 self.change_i 0 self.change_d 0 def pid_calc(self, reference, feedback):#reference 目标位置\tfeedback 当前位置 self.last_error self.error_sum self.error_sum reference feedback #获取新的误差 #计算微分 dout (self.error_sum self.last_error) * self.kd #计算比例 pout self.error_sum * self.kp #计算积分 self.change_i + self.error_sum * self.ki #积分限幅 if self.change_i > self.max_change_i : self.change_i self.max_change_i elif self.change_i < self.max_change_i: self.change_i self.max_change_i #计算输出 self.output pout + dout + self.change_i #输出限幅 if self.output > self.maxOutput: self.output self.maxOutput elif self.output < self.maxOutput: self.output self.maxOutput return self.output ``` 将上面的代码保存，并且对整个文件命名为 pid.py，完成后上传到K230的sdcard文件夹里面。 ![图 16](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 08 12.png) 接下来是如何使用这个库。在我们的main.py代码中，引入该文件： ```python from pid import PID ``` 然后创建 PID 对象，并对其静态参数进行设置： ```python lr_kp 0.013 lr_ki 0.0008 lr_kd 0.016 lr_max_out 12.5 #最大输出 pid_lr PID(lr_kp, lr_ki, lr_kd, 10, lr_max_out) #创建左右电机的PID对象 ud_kp 0.013 ud_ki 0.00091 ud_kd 0.02 ud_max_out 12.5 #最大输出 pid_ud PID(ud_kp, ud_ki, ud_kd, 10, ud_max_out) #创建上下电机的PID对象 ``` 创建 PID 对象后，应用到我们的舵机动作代码中，我将关键代码取出分析： ```python # 如果找到了至少一个目标色块 if blobs: # 找到最大的目标色块 largest_blob max(blobs, key lambda b: b.pixels()) # 给目标色块画框标记出来 img.draw_rectangle(largest_blob.rect(), color (255, 0, 0)) # 在标记框内画十字，标记中心点 img.draw_cross(largest_blob.cx(), largest_blob.cy(), color (255, 0, 0)) # 计算目标色块相对于屏幕中心的X轴和Y轴的偏移量 x_offset largest_blob.cx() img.width() // 2 y_offset largest_blob.cy() img.height() // 2 # 在屏幕显示目标色块的位置信息和像素大小，包含正负号 wz \"x {}, y {}, w {}, h {}\".format(x_offset, y_offset, largest_blob.w(), largest_blob.h()) \t# 显示字符串 img.draw_string_advanced(0,0,32,wz) # 根据中心偏移量计算PWM的PID # 0为目标值，x_offset表示当前设定值 pid_lr_value pid_lr.pid_calc(0,x_offset) pid_ud_value pid_ud.pid_calc(0,y_offset) \t\t\t''' 关键点一 ''' # 将PID值转换为舵机的范围并且输出实际的占空比 duty_lr_value input_to_duty_cycle(pid_lr_value) duty_ud_value input_to_duty_cycle(pid_ud_value) \t\t\t''' 关键点二 ''' # 根据计算后的占空比控制舵机动作 #pwm_lr.duty(duty_lr_value) #pwm_ud.duty(duty_ud_value) ``` > lr表示左右旋转的舵机，ud表示上下旋转的舵机。 大家可以在上面的代码中看到 **关键点一** 和 **关键点二** 的注释，在关键点一的位置可以通过`print`输出一下`PID`计算后的值`pid_lr_value`；在关键点二的位置输出实际占空比值`duty_lr_value`。 ```python print(f\"pid_lr_value {pid_lr_value}, pid_ud_value {pid_ud_value}\\r\\n\") print(f\"duty_lr_value {duty_lr_value}, duty_ud_value {duty_ud_value}\\r\\n\") ``` ![图 17](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 18 34.gif) #### PID调参 当大家取消舵机动作的注释并下载执行后，会发现这个PID的效果并不理想，有的反应慢，有的反应快，有的基本没有动。这个是因为我们没有调好PID。 ![图 19](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 36 26.gif) 那如何调整好PID的参数呢？ 在实际应用中，需要对PID控制器的参数 `Kp \\ Ki \\ Kd` 进行调整，以达到理想的控制效果。这通常通过以下步骤进行： * **先设定比例增益 `Kp`** ：使系统响应快速，但可能会出现稳态误差。 * **调整积分增益 `Ki`** ：消除稳态误差，但要注意超调和振荡。 * **最后调整微分增益 `Kd`** ：改善系统的动态行为，减少超调和振荡。 我调试 PID 是通过串口 和 [Vofa+工具](https://www.vofa.plus/)。Vofa+是一款上位机工具，我个人认为目前对这个项目来说最大的作用是显示出数据波形变化。 <table> <thead> <tr> <th><img src \"../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 23 55.png\" width \"1200\"></th> </tr> <tr> <th><center>Vofa+ 上位机界面</center></th> </tr> </thead> </table> 目前我还不知道K230的单步调试手段，所以只能盲调PID：设置一个P\\I\\D值，然后看PID输出的数据曲线和目标数据曲线的差别。如果误差很大，则重新设置一个P\\I\\D值继续调到误差小为止。 当然，如果有时间和精力，也可以自己写一套通过串口调整参数的代码。 **硬件连接** > 图中的这个带金边的模块是CH340的USB转串口模块，是很常用的东西了。这个因为没有找到更好的实物图，就找了这个，现在这个图模块上的RXD和TXD接到一起了，实际连接的时候是**不要短接在一起的，** 切记。 ![图 20](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 38 08.png) 我们通过下面的代码测试一下k230的串口发送功能 和 vofa+的使用： > K230的串口知识和使用方法，参考立创开发板的[庐山派串口章节教程](https://wiki.lckfb.com/zh hans/lushan pi k230/basic/uart.html) ```python from machine import UART from machine import FPIOA # 配置引脚 fpioa FPIOA() fpioa.set_function(5, FPIOA.UART2_TXD) fpioa.set_function(6, FPIOA.UART2_RXD) # 初始化UART2，波特率115200，8位数据位，无校验，1位停止位 uart UART(UART.UART2, baudrate 115200, bits UART.EIGHTBITS, parity UART.PARITY_NONE, stop UART.STOPBITS_ONE) # 要发送的字符串 message \"Hello,LuShan Pi!\\r\\n\" # 通过UART发送数据 uart.write(message) # 释放UART资源 uart.deinit() ``` 效果图： ![图 21](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 39 15.png) #### Vofa+的使用 这里就介绍Vofa+的数据接收协议 和 波形的显示方法。 **接收协议** 比较常用的是 FireWater协议，其协议格式如下： ```txt <any>:ch0,ch1,ch2,...,chN\\n ``` 参数说明： 元素 描述 **\\<any\\>** 表示数据名称，可以自定义 **:** 必须加英文冒号，不然解析不了数据，就不会显示在Vofa+上。 **ch0~chN** ch表示通道数据，0~N表示是第几个通道的数据。比如我要发送两个浮点数据（float）到vofa+显示波形，分别是1.2 和 21.4。那么就可以写为 `float:1.2,21.4\\n`，这样就可以显示两个数据。 **,** 表示每一个数据之间的间隔 **\\n** 结尾必须加\\n，不然解析不了数据，就不会显示在Vofa+上。 示例： ```c float:1.2,21.4\\n temp:25.3\\n sensor:0.5,1.7,3.2\\n ``` >! **关键注意事项** >! 1. ​**​冒号不能省略​**​：数据名称后必须立即跟英文冒号（`:`） >! 2. ​**​逗号分隔数据​**​：多个数值必须用英文逗号（`,`）分隔 >! 3. ​**​结尾必须有`\\n`​**​：换行符是数据结束的强制标记 >! 4. ​**​通道顺序​**​：数据值的顺序对应通道索引（第一个值 ch0，第二个值 ch1，以此类推） <table> <thead> <tr> <th><img src \"../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 46 26.png\" width \"1200\"></th> </tr> <tr> <th><center>Vofa+ 上关于 FireWater 协议的描述</center></th> </tr> </thead> </table> #### 波形显示 在 Vofa+ 的左侧边栏找控件，将波形图控件拉出到放置区即可。 <table> <thead> <tr> <th><img src \"../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 47 31.png\" width \"1200\"></th> </tr> <tr> <th><center>放置波形图控件</center></th> </tr> </thead> </table> 我们可以通过 Vofa+ 本身自己带的 Demo 数据测试能不能显示出波形。 不过 Vofa+ 接收到数据后，还不能马上显示在波形图上，还需要我们配置波形的输入数据。 <table> <thead> <tr> <th><img src \"../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 49 46.png\" width \"600\"></th> \t <th><img src \"../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 49 21.png\" width \"600\"></th> </tr> <tr> <th><center>放大波形画面</center></th> \t <th><center>设置波形的输入显示数据</center></th> </tr> </thead> </table> 不出意外的话，你应该会显示下面的画面： > 5个通道的数据，不断更新就可以得到波形。 <table> <thead> <tr> <th><img src \"../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 26 23 53 08.png\" width \"1200\"></th> </tr> <tr> <th><center>波形显示画面</center></th> </tr> </thead> </table> 现在各位就可以自行调试你的PID啦。 #### 加PID后的效果及代码 如果你发现你往左，而舵机往右，说明极性反了，让参数变成负数即可。 如果你发现响应速度慢，那就加大 Kp 值。 如果你发现，图像的中心跟目标的中心始终有误差，那你就加大 Ki 值；如果舵机一直在目标位置反复横跳抖动，那你就减小 Ki 值。 如果你想实现了PID的基本快速追踪，想让它更快，那就调整 Kd 值。 这个是我的调试结果： ![图 27](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 27 00 27 29.gif) 实现这个效果的代码： ```python import time, os, gc, sys, math,utime from machine import PWM, FPIOA, Pin, UART from media.sensor import * from media.display import * from media.media import * from pid import PID DETECT_WIDTH 640 DETECT_HEIGHT 480 sensor None ###############################舵机配置##################################################### # 2.5 90度 7.5 0度 12.5 90度 min_duty 2.5 #最小占空比 max_duty 12.5 #最大占空比 mid_duty 7.5 # 中间值，对应于0度 pwm_lr None # 配置排针引脚号12，芯片引脚号为47的排针复用为PWM通道3输出 pwm_io1 FPIOA() pwm_io1.set_function(47, FPIOA.PWM3) # 初始化PWM参数 pwm_ud PWM(3, 50, 50, enable True) # 默认频率50Hz,占空比50% 3~12 # 配置排针引脚号32，芯片引脚号为46的排针复用为PWM通道2输出 pwm_io2 FPIOA() pwm_io2.set_function(46, FPIOA.PWM2) # 初始化PWM参数 pwm_lr PWM(2, 50, 50, enable True) # 默认频率50Hz,占空比50% 2~13 pwm_lr.duty(7.5) #旋转到中间 pwm_ud.duty(4) #旋转到中间 ########################################################################################## ###############################PID配置##################################################### lr_kp 0.17 lr_ki 0.016 lr_kd 0 lr_max_out DETECT_WIDTH//2\t\t#PID最大输出 pid_lr PID(lr_kp, lr_ki, lr_kd, lr_max_out, lr_max_out) ud_kp 0.17 ud_ki 0.016 ud_kd 0 ud_max_out DETECT_HEIGHT//2\t\t#PID最大输出 pid_ud PID(ud_kp, ud_ki, ud_kd, ud_max_out, ud_max_out) ########################################################################################## ## 将Y轴偏移数值转换为占空比的函数 def input_to_duty_cycle(input_min, input_max, input_value): # 定义输入输出范围 # input_min (DETECT_HEIGHT // 2) # input_max (DETECT_HEIGHT // 2) output_min min_duty output_max max_duty # 检查输入是否越界 if input_value < input_min or input_value > input_max: raise ValueError(f\"输入值必须在 {input_min} 和 {input_max} 之间\") # 计算线性映射公式 slope (output_max output_min) / (input_max input_min) output_value output_min + (input_value input_min) * slope return output_value try: # 初始化摄像头 sensor Sensor(width DETECT_WIDTH, height DETECT_HEIGHT) # 传感器复位 sensor.reset() # 开启镜像 sensor.set_hmirror(True)#False # sensor vflip sensor.set_vflip(True)#False True # 设置图像一帧的大小 sensor.set_framesize(width DETECT_WIDTH, height DETECT_HEIGHT) # 设置图像输出格式为彩色的RGB565 sensor.set_pixformat(Sensor.RGB565) # 使用IDE显示图像 Display.init(Display.VIRT, width DETECT_WIDTH, height DETECT_HEIGHT, fps 100) # 初始化媒体管理器 MediaManager.init() # 摄像头传感器开启运行 sensor.run() # 定义要识别颜色的阈值，这里需要根据你的具体情况调整 # 你可以通过尝试不同的阈值来找到最适合你的物体颜色值 red_threshold (0, 42, 17, 94, 6, 50) while True: # 拍摄一张图片 img sensor.snapshot() # 查找图像中满足红色阈值的区域 blobs img.find_blobs([red_threshold], pixels_threshold 200, area_threshold 200, merge True) # 如果找到了至少一个blob if blobs: # 找到最大的blob largest_blob max(blobs, key lambda b: b.pixels()) # 画框 img.draw_rectangle(largest_blob.rect(), color (255, 0, 0)) # 在框内画十字，标记中心点 img.draw_cross(largest_blob.cx(), largest_blob.cy(), color (255, 0, 0)) # 计算相对于屏幕中心的X轴和Y轴的偏移量 x_offset largest_blob.cx() img.width() // 2 y_offset largest_blob.cy() img.height() // 2 # 屏幕显示位置信息和像素大小，包含正负号 wz \"x {}, y {}, w {}, h {}\".format(x_offset, y_offset, largest_blob.w(), largest_blob.h()) img.draw_string_advanced(0,0,32,wz) # 根据中心偏移量计算PWM的PID # 0为目标值，x_offset表示当前设定值 pid_lr_value pid_lr.pid_calc(0,x_offset) pid_ud_value pid_ud.pid_calc(0,y_offset) ''' 关键点一 ''' # 将PID值转换为舵机的范围并且输出实际的占空比 duty_lr_value input_to_duty_cycle( (DETECT_WIDTH // 2), (DETECT_WIDTH // 2), pid_lr_value) duty_ud_value input_to_duty_cycle( (DETECT_HEIGHT // 2), (DETECT_HEIGHT // 2), pid_ud_value) print(f\"pid_lr_value {pid_lr_value}, pid_ud_value {pid_ud_value}\\r\\n\") print(f\"duty_lr_value {duty_lr_value}, duty_ud_value {duty_ud_value}\\r\\n\") ''' 关键点二 ''' # 根据计算后的占空比控制舵机动作 pwm_lr.duty(duty_lr_value) pwm_ud.duty(duty_ud_value) # 中心画十字 img.draw_cross(img.width() // 2, img.height() // 2, color (0, 255, 0), size 10, thickness 3) # IDE显示图片 Display.show_image(img) except KeyboardInterrupt as e: print(f\"user stop\") except BaseException as e: print(f\"Exception &#039;{e}&#039;\") finally: # sensor stop run if isinstance(sensor, Sensor): sensor.stop() # deinit display Display.deinit() if isinstance(pwm_lr, PWM): pwm_lr.deinit() # release media buffer MediaManager.deinit() os.exitpoint(os.EXITPOINT_ENABLE_SLEEP) time.sleep_ms(100) ``` ### 数据滤波 相信大家在调试的时候，会发现识别物体的中心位置跳变非常频繁，识别的物体明明根本没有动，但是因为识别代码的问题，识别的位置一直在变动，有时候变动小，有时候变动大。这个变动会影响到我们的PID计算，导致舵机不稳定：识别到物体后，明明舵机已经指向识别物体的中心了，但是舵机还是会有一些动作调整，导致一直动，都不停的。 那为了解决这个问题，我们就可以使用滤波的方式，将数据跳变不大的时候，过滤掉。最简单的滤波就是采集多次然后取平均值，这个平均值就是滤波后的结果。 如果你的PID没有调好，那也可以直接用滤波，应该也可以实现一个比较不错的效果。 这里我用一个比较常用的滤波算法：**`一阶低通滤波算法`**。 我将代码封装成为了一个库文件，将下面代码保存并命名为 filter.py，完成后上传到K230的sdcard文件夹里面。 ```python #一阶低通滤波器 class LowPassFilter: def __init__(self, alpha): self.alpha alpha # 滤波器的系数，0 < alpha < 1 self.last_output None def update(self, value): if self.last_output is None: # 初始化滤波器的输出 self.last_output value else: # 更新滤波器的输出 self.last_output self.alpha * value + (1 self.alpha) * self.last_output return self.last_output ``` ![图 28](../../static/images/docs/diy/tracking cannon/basic/basic 2025 06 27 00 52 59.png) 接下来是介绍如何使用这个滤波算法，首先使用前先导入库： ```python from filter import LowPassFilter ``` 然后初始化滤波参数： ```python #滤波 alpha 0.1 # 滤波器系数，您可以根据需要调整这个值 lr_filter LowPassFilter(alpha) # 左右舵机滤波器 ``` 接着在关键代码中调用API函数 `.update`，比如我采集的位置数据是 pid_lr_value，我要对其滤波则输入pid_lr_value，API`.update`返回的数值就是滤波后的数值： ```python # 对目标物体的中心位置进行滤波 filter_lr_value lr_filter.update(x_offset) filter_ud_value ud_filter.update(y_offset) ``` 实现效果： ![图 10](../../static/images/docs/diy/tracking cannon/basic/basic 2024 12 22 00 06 01.gif) 完整代码： ```python import time, os, gc, sys, math,utime from machine import PWM, FPIOA, Pin, UART from media.sensor import * from media.display import * from media.media import * from pid import PID from filter import LowPassFilter DETECT_WIDTH 640 DETECT_HEIGHT 480 sensor None ###############################舵机配置##################################################### # 2.5 90度 7.5 0度 12.5 90度 min_duty 2.5 #最小占空比 max_duty 12.5 #最大占空比 mid_duty 7.5 # 中间值，对应于0度 pwm_lr None # 配置排针引脚号12，芯片引脚号为47的排针复用为PWM通道3输出 pwm_io1 FPIOA() pwm_io1.set_function(47, FPIOA.PWM3) # 初始化PWM参数 pwm_ud PWM(3, 50, 50, enable True) # 默认频率50Hz,占空比50% 3~12 # 配置排针引脚号32，芯片引脚号为46的排针复用为PWM通道2输出 pwm_io2 FPIOA() pwm_io2.set_function(46, FPIOA.PWM2) # 初始化PWM参数 pwm_lr PWM(2, 50, 50, enable True) # 默认频率50Hz,占空比50% 2~13 pwm_lr.duty(7.5) #旋转到中间 pwm_ud.duty(7.7) #旋转到中间 ########################################################################################## ###############################PID配置##################################################### lr_kp 0.17 lr_ki 0.016 lr_kd 0 lr_max_out DETECT_WIDTH//2\t\t#PID最大输出 pid_lr PID(lr_kp, lr_ki, lr_kd, lr_max_out, lr_max_out) ud_kp 0.17 ud_ki 0.016 ud_kd 0 ud_max_out DETECT_HEIGHT//2\t\t#PID最大输出 pid_ud PID(ud_kp, ud_ki, ud_kd, ud_max_out, ud_max_out) ########################################################################################## ###############################一阶低通滤波器配置############################################ alpha 0.1 # 滤波器系数，您可以根据需要调整这个值 lr_filter LowPassFilter(alpha) # 左右舵机滤波器 ud_filter LowPassFilter(alpha) # 上下舵机滤波器 ########################################################################################## ## 将Y轴偏移数值转换为占空比的函数 def input_to_duty_cycle(input_min, input_max, input_value): # 定义输入输出范围 # input_min (DETECT_HEIGHT // 2) # input_max (DETECT_HEIGHT // 2) output_min min_duty output_max max_duty # 检查输入是否越界 if input_value < input_min or input_value > input_max: raise ValueError(f\"输入值必须在 {input_min} 和 {input_max} 之间\") # 计算线性映射公式 slope (output_max output_min) / (input_max input_min) output_value output_min + (input_value input_min) * slope return output_value try: # 初始化摄像头 sensor Sensor(width DETECT_WIDTH, height DETECT_HEIGHT) # 传感器复位 sensor.reset() # 开启镜像 sensor.set_hmirror(True)#False # sensor vflip sensor.set_vflip(True)#False True # 设置图像一帧的大小 sensor.set_framesize(width DETECT_WIDTH, height DETECT_HEIGHT) # 设置图像输出格式为彩色的RGB565 sensor.set_pixformat(Sensor.RGB565) # 使用IDE显示图像 Display.init(Display.VIRT, width DETECT_WIDTH, height DETECT_HEIGHT, fps 100) # 初始化媒体管理器 MediaManager.init() # 摄像头传感器开启运行 sensor.run() # 定义要识别颜色的阈值，这里需要根据你的具体情况调整 # 你可以通过尝试不同的阈值来找到最适合你的物体颜色值 red_threshold (0, 42, 17, 94, 6, 50) while True: # 拍摄一张图片 img sensor.snapshot() # 查找图像中满足红色阈值的区域 blobs img.find_blobs([red_threshold], pixels_threshold 400, area_threshold 400, merge True) # 如果找到了至少一个blob if blobs: # 找到最大的blob largest_blob max(blobs, key lambda b: b.pixels()) # 画框 img.draw_rectangle(largest_blob.rect(), color (255, 0, 0)) # 在框内画十字，标记中心点 img.draw_cross(largest_blob.cx(), largest_blob.cy(), color (255, 0, 0)) # 计算相对于屏幕中心的X轴和Y轴的偏移量 x_offset largest_blob.cx() img.width() // 2 y_offset largest_blob.cy() img.height() // 2 # 屏幕显示位置信息和像素大小，包含正负号 wz \"x {}, y {}, w {}, h {}\".format(x_offset, y_offset, largest_blob.w(), largest_blob.h()) img.draw_string_advanced(0,0,32,wz) # 对目标物体的中心位置进行滤波 filter_lr_value lr_filter.update(x_offset) filter_ud_value ud_filter.update(y_offset) # 根据中心偏移量计算PWM的PID # 0为目标值，x_offset表示当前设定值 pid_lr_value pid_lr.pid_calc(0,filter_lr_value) pid_ud_value pid_ud.pid_calc(0,filter_ud_value) # 将PID值转换为舵机的范围并且输出实际的占空比 duty_lr_value input_to_duty_cycle( (DETECT_WIDTH // 2), (DETECT_WIDTH // 2), pid_lr_value) duty_ud_value input_to_duty_cycle( (DETECT_HEIGHT // 2), (DETECT_HEIGHT // 2), pid_ud_value) # 根据计算后的占空比控制舵机动作 pwm_lr.duty(duty_lr_value) pwm_ud.duty(duty_ud_value) # 中心画十字 img.draw_cross(img.width() // 2, img.height() // 2, color (0, 255, 0), size 10, thickness 3) # IDE显示图片 Display.show_image(img) except KeyboardInterrupt as e: print(f\"user stop\") except BaseException as e: print(f\"Exception &#039;{e}&#039;\") finally: # sensor stop run if isinstance(sensor, Sensor): sensor.stop() # deinit display Display.deinit() if isinstance(pwm_lr, PWM): pwm_lr.deinit() # release media buffer MediaManager.deinit() os.exitpoint(os.EXITPOINT_ENABLE_SLEEP) time.sleep_ms(100) ```"},"/diy/picxel-clock/download.html":{"title":"像素时钟资料下载","content":" title: 像素时钟资料下载 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 项目开源地址 >! 开源地址：https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock 如果你喜欢这个项目，鼓励鼓励，给开源项目点个⭐Star吧~ ## 固件下载 >! 下载地址：https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/firmware ### 当前固件 序号 固件名称 更新时间 备注 1 ESP32S3R8N8_PixelClock_0.0.1.bin 2024 07 28 包含 时钟 / 天气 / 温湿度 / 数字雨 / 音律拾音灯 2 ESP32S3R8N8_PixelClock_0.0.2.bin 2024 07 28 包含 时钟 / 天气 / 温湿度 / 数字雨 / 音律拾音灯 / WIFI配网 ### 固件烧录步骤 使用乐鑫的[FLASH下载器](https://www.espressif.com.cn/zh hans/support/download/other tools)。 ![图 3](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 37 52.png) 下载后运行。固件烧录操作如下： ![图 4](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 37 55.png) 烧录完成之后断电重启即可。 ### 在PlatformIO中生成固件 参考：https://blog.csdn.net/Argon_Ghost/article/details/139307638?ops_request_misc &request_id &biz_id 102&utm_term PlatformIO%E7%94%9F%E6%88%90%E5%9B%BA%E4%BB%B6&utm_medium distribute.pc_search_result.none task blog 2~all~sobaiduweb~default 1 139307638.142^v100^pc_search_result_base4&spm 1018.2226.3001.4187 ## 3D外壳文件下载 >! 下载地址：https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/3Dfile ### 3D文件说明 **因为实物很大，打印的外壳需要分开，分左右两边。** LEDGrid2x.stl 为光栏，需要一个部件打两个，拼到一起； > 说明：光栏一定要黑色的材质，不管是3D打印时选择黑色的材料还是后面收到喷黑漆，一定记得使用黑色的光栏！不然观感就差很多 ![图 0](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 32 35.png) frontFrame2x.stl 为外壳边框，需要一个部件打两个，拼到一起； ![图 1](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 32 50.png) Housing.stl 和 Housing_noV.stl 为同一个部件，选择一个进行打印即可，都是成本较高，酌情打印； ![图 2](../../static/images/docs/diy/picxel clock/download/download 2024 12 05 22 32 57.png) 如要组建完整的外壳，还需要购买黑色的亚克力透明面板！ ``生产的规格参数：黑茶色 透明亚克力 95×330×2mm``"},"/diy/picxel-clock/led-oscillating.html":{"title":"FFT音律灯","content":" title: FFT音律灯 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 >! 本文继承自之前的👉[彩灯驱动](ledmatrix.html)章节 **本文完成的效果：** ![图 0](../../static/images/docs/diy/picxel clock/led oscillating/led oscillating 2024 12 06 00 05 00.gif) ## 硬件准备 ### WS2812矩阵彩灯 ![图 0](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 14 08.png) **购买地址：**[WS2812B全彩软像素屏8X8 8X32 16X16幻彩5V显示可编程像素软屏](https://item.taobao.com/item.htm?spm a1z09.2.0.0.24ee2e8dC5LwBl&id 737696448369&_u r2t4uge57a73&skuId 5263566850408) ### 麦克风模块 ![图 1](../../static/images/docs/diy/picxel clock/led oscillating/led oscillating 2024 12 06 00 05 36.png) 购买地址：[GY MAX4466 声音传感器模块 MAX4466麦克风前置放大器 提供程序](https://item.taobao.com/item.htm?spm a21n57.1.item.2.2af5523csIlNsa&priceTId 2147bfce17220928379633421e49bd&utparam %7B%22aplus_abtest%22:%22c7a787e4caab2b1c51f9ce5bba439f54%22%7D&id 619436010637&ns 1&abbucket 4) ### ESP32S3开发板 ![图 1](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 14 24.png) **购买地址：**[立创·ESP32S3R8N8 开发板](https://item.szlcsc.com/22034693.html?fromZone s_s__%2522%25E7%25AB%258B%25E5%2588%259B%25E5%25BC%2580%25E5%258F%2591%25E6%259D%25BF%2522) ## 工程创建 在VSCode中打开PlatformIO扩展创建名为`OscillatingLED`的 `Espressif ESP32 S3 DevKitM 1` 工程。 关于详细图文创建工程的过程请参考👉[RTC时钟驱动](ds1302.html)章节的工程创建小节。 ## 安装驱动库 创建完成之后，打开驱动库下载界面。实现功能的最底层的驱动，需要分别安装三个库： 1. 搜索``Adafruit NeoMatrix``，安装来自``Adafruit``的``Adafruit NeoMatrix``库。 2. 搜索``Adafruit GFX Library``，安装来自``Adafruit``的``Adafruit GFX Library``库。 3. 搜索``arduinoFFT``，安装来自``Enrique Condes``的``arduinoFFT``库。 将它们都安装到我们的工程当中。 > 关于详细图文安装驱动库的过程请参考👉[RTC时钟驱动](ds1302.html)章节的安装驱动库小节。 都安装完成之后，打开``platformio.ini``文件，应该可以看到已经安装上了三个驱动库。 ![图 2](../../static/images/docs/diy/picxel clock/led oscillating/led oscillating 2024 12 06 00 07 06.png) ## 编辑代码 在工程下的``include``文件夹下新建一个 ``musicfft.h``文件。 接下来往 ``musicfft.h`` 文件写入代码： ```c #include <Adafruit_NeoMatrix.h> #include <arduinoFFT.h> #define CHANNEL 1 //音频输入引脚 #define xres 32 #define yres 8 const uint16_t samples 64; //采样点数，必须为2的整数次幂 const double samplingFrequency 4000; //Hz, 声音采样频率 unsigned int sampling_period_us; unsigned long microseconds; unsigned long lastTime 0; unsigned long fallingTime 0; double vReal[samples]; //FFT采样输入样本数组 double vImag[samples]; //FFT运算输出数组 int freq_gain2[xres] {30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30}; int Intensity[xres] {}; // initialize Frequency Intensity to zero int FallingPoint[xres] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; int Displacement 1; // Create LED Object //ArduinoFFT FFT ArduinoFFT(); //创建FFT对象 ArduinoFFT<double> FFT ArduinoFFT<double>(vReal, vImag, samples, samplingFrequency); void getSamples(){ microseconds micros(); for(int i 0; i < samples; i++){ vReal[i] analogRead(CHANNEL); vImag[i] 0; microseconds + sampling_period_us; } bool reduce false; if ((millis() lastTime) > 16) { lastTime millis(); reduce true; } //FFT FFT.windowing(vReal, 1, FFT_WIN_TYP_HAMMING, FFT_FORWARD); FFT.compute(vReal, vImag, samples, FFT_FORWARD); FFT.complexToMagnitude(vReal, vImag, samples); //Update Intensity Array int t 16; for(int i t; i < (xres*Displacement)+t; i+ Displacement){ vReal[i] constrain(vReal[i], 0 ,3596); // set max value for input data vReal[i] map(vReal[i], freq_gain2[(i t)/Displacement], 1548, 0, yres); // map data to fit our display if(reduce){ Intensity[(i t)/Displacement] ; // Decrease displayed value } if (vReal[i] > Intensity[(i t)/Displacement]) // Match displayed value to measured value Intensity[(i t)/Displacement] vReal[i]; } } void drawYLine(Adafruit_NeoMatrix *matrix, int16_t x, int16_t y, int16_t h, int16_t c){ for(int i y;i<y+h;i++){ matrix >drawPixel(x,7 i,c); } } uint16_t hsv2rgb2(Adafruit_NeoMatrix *matrix, uint16_t hue, uint8_t saturation, uint8_t value) { uint8_t red 0; uint8_t green 0; uint8_t blue 0; uint16_t hi (hue / 60) % 6; uint16_t F 100 * hue / 60 100 * hi; uint16_t P value * (100 saturation) / 100; uint16_t Q value * (10000 F * saturation) / 10000; uint16_t T value * (10000 saturation * (100 F)) / 10000; switch (hi) { case 0: red value; green T; blue P; break; case 1: red Q; green value; blue P; break; case 2: red P; green value; blue T; break; case 3: red P; green Q; blue value; break; case 4: red T; green P; blue value; break; case 5: red value; green P; blue Q; break; default: return matrix >Color(255, 0, 0); } red red * 255 / 100; green green * 255 / 100; blue blue * 255 / 100; return matrix >Color(red, green, blue); } void displayUpdate(Adafruit_NeoMatrix *matrix, int displayPattern){ int color 0; switch(displayPattern){ case 0: for(int i 0; i < xres; i++){ drawYLine(matrix,i,yres Intensity[i],Intensity[i],hsv2rgb2(matrix, color, 80, 80 )); drawYLine(matrix,i,0,yres 1 Intensity[i],hsv2rgb2(matrix, color, 80, 80 )); color + 360/xres; } break; case 1: if ((millis() fallingTime) > 130) { for(int i 0; i < xres; i++){ if(FallingPoint[i]>0){ FallingPoint[i] ; } } fallingTime millis(); } for(int i 0; i < xres; i++){ drawYLine(matrix,i,0,yres 1,matrix >Color(0,0,0)); if(FallingPoint[i]<Intensity[i]){ FallingPoint[i] Intensity[i]; } drawYLine(matrix,i,yres Intensity[i]+1,Intensity[i] 1,hsv2rgb2(matrix, color, 80, 80 )); if(FallingPoint[i]>0){ matrix >drawPixel(i,yres FallingPoint[i],matrix >Color(255,255,255)); } color + 360/xres; } break; case 2: for(int i 0; i < xres; i++){ drawYLine(matrix,i,0,yres,matrix >Color(0,0,0)); drawYLine(matrix,i,0,Intensity[i]+1,hsv2rgb2(matrix, color, 80, 80 )); color + 360/xres; } break; } } ``` 接下来在 ``main.cpp``中编写以下代码： ```c #include <Arduino.h> #include <Adafruit_NeoMatrix.h> //点亮LED矩阵需要的库 #include \"musicfft.h\" //音乐频谱库 //像素阵列定义 #define kMatrixWidth 32 //宽度 #define kMatrixHeight 8 //高度 #define BRIGHTNESS 10 //默认亮度 0 255 #define BRIGHTNESS_INTERVAL 30 //亮度调节间隔 #define LED_PIN 8 //像素阵列引脚 Adafruit_NeoMatrix *matrix; //LED矩阵类指针 //像素矩阵初始化 void InitLED_Matrix(void) { //设置像素矩阵的方向以及排列方式 matrix new Adafruit_NeoMatrix(32, 8, LED_PIN, NEO_MATRIX_TOP + NEO_MATRIX_LEFT+ NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); matrix >setTextWrap(false); //设置文字是否自动换行 matrix >clear(); //清除当前显示内容 matrix >setBrightness(BRIGHTNESS);//设置亮度 } void showFFT(void) { //进行采样 getSamples(); //更新频谱柱 displayUpdate(matrix, 2); } void setup() { //初始化LED矩阵显示 InitLED_Matrix(); } void loop() { matrix >clear(); showFFT(); matrix >show(); delay(50); } ``` ## 硬件连接 ![图 3](../../static/images/docs/diy/picxel clock/led oscillating/led oscillating 2024 12 06 00 08 04.png) # 6. 代码验证 代码编写完成之后，将ESP32S3开发板接入电脑下载代码。然后观察彩灯矩阵的现象。 实物显示如下： **使用黑色亚克力面板+白纸格挡光线显示** > 叠层从上到下是这样的：黑色亚克力面板 > 白纸 > LED矩阵 ![图 0](../../static/images/docs/diy/picxel clock/led oscillating/led oscillating 2024 12 06 00 05 00.gif) >! 说明：如果你根据代码操作运行不起来，可以下载👉[例程](https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/example/OscillatingLED)看看"},"/diy/picxel-clock/ledmatrix.html":{"title":"彩灯驱动","content":" title: 彩灯驱动 keywords: keyword1, keyword2 desc: description for this article show_source: false excerpt_separator: \"\" update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 硬件准备 ### WS2812矩阵彩灯 ![图 0](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 14 08.png) **购买地址：**[WS2812B全彩软像素屏8X8 8X32 16X16幻彩5V显示可编程像素软屏](https://item.taobao.com/item.htm?spm a1z09.2.0.0.24ee2e8dC5LwBl&id 737696448369&_u r2t4uge57a73&skuId 5263566850408) ### ESP32S3开发板 ![图 1](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 14 24.png) **购买地址：**[立创·ESP32S3R8N8 开发板](https://item.szlcsc.com/22034693.html?fromZone s_s__%2522%25E7%25AB%258B%25E5%2588%259B%25E5%25BC%2580%25E5%258F%2591%25E6%259D%25BF%2522) ## 工程创建 在VSCode中打开PlatformIO扩展创建名为`LEDMatrix`的 `Espressif ESP32 S3 DevKitM 1` 工程。 关于详细图文创建工程的过程请参考👉[RTC时钟驱动](ds1302.html)章节的工程创建小节。 ## 安装驱动库 最底层的驱动，需要分别安装两个库： 1. 搜索``Adafruit NeoMatrix``，安装来自``Adafruit``的``Adafruit NeoMatrix``库。 2. 搜索``Adafruit GFX Library``，安装来自``Adafruit``的``Adafruit GFX Library``库。 将它们都安装到我们的工程当中。 > 关于详细图文安装驱动库的过程请参考👉[RTC时钟驱动](ds1302.html)章节的安装驱动库小节。 都安装完成之后，打开``platformio.ini``文件，可以看到已经安装上了两个驱动库。 ![图 2](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 16 11.png) ## 编辑代码 首先导入我们的字库，这里我提供给大家一个ascii的字库。在工程下的``include``文件夹下新建一个 ``my_font.h``文件。 接下来往 ``my_font.h`` 文件写入我们的字模代码： > 直接复制以下代码到你的文件下 ```c #include \"Arduino.h\" #include \"Adafruit_GFX.h\" const uint8_t PicopixelBitmaps[] PROGMEM { 0xE8, 0xB4, 0x57, 0xD5, 0xF5, 0x00, 0x4E, 0x3E, 0x80, 0xA5, 0x4A, 0x4A, 0x5A, 0x50, 0x80, 0x6A, 0x40, 0x95, 0x80, 0xAA, 0x80, 0x5D, 0x00, 0x60, 0xE0, 0x80, 0x25, 0x48, 0xF6, 0xDE, 0x59, 0x2E, 0xE7, 0xCE, 0xE7, 0x9E, 0xB7, 0x92, 0xF3, 0x9E, 0xF3, 0xDE, 0xE4, 0x92, 0xF7, 0xDE, 0xF7, 0x9E, 0xA0, 0x46, 0x64, 0xE3, 0x80, 0x98, 0xC5, 0x04, 0x56, 0xC6, 0x57, 0xDA, 0xD7, 0x5C, 0x72, 0x46, 0xD6, 0xDC, 0xF3, 0xCE, 0xF3, 0x48, 0x72, 0xD4, 0xB7, 0xDA, 0xF8, 0x24, 0xD4, 0xBB, 0x5A, 0x92, 0x4E, 0x8E, 0xEB, 0x58, 0x80, 0x9D, 0xB9, 0x90, 0x56, 0xD4, 0xD7, 0x48, 0x56, 0xD4, 0x40, 0xD7, 0x5A, 0x71, 0x1C, 0xE9, 0x24, 0xB6, 0xD4, 0xB6, 0xA4, 0x8C, 0x6B, 0x55, 0x00, 0xB5, 0x5A, 0xB5, 0x24, 0xE5, 0x4E, 0xEA, 0xC0, 0x91, 0x12, 0xD5, 0xC0, 0x54, 0xF0, 0x90, 0xC7, 0xF0, 0x93, 0x5E, 0x71, 0x80, 0x25, 0xDE, 0x5E, 0x30, 0x6E, 0x80, 0x77, 0x9C, 0x93, 0x5A, 0xB8, 0x45, 0x60, 0x92, 0xEA, 0xAA, 0x40, 0xD5, 0x6A, 0xD6, 0x80, 0x55, 0x00, 0xD7, 0x40, 0x75, 0x90, 0xE8, 0x71, 0xE0, 0xBA, 0x40, 0xB5, 0x80, 0xB5, 0x00, 0x8D, 0x54, 0xAA, 0x80, 0xAC, 0xE0, 0xE5, 0x70, 0x6A, 0x26, 0xFC, 0xC8, 0xAC, 0x5A}; const GFXglyph PicopixelGlyphs[] PROGMEM { {0, 0, 0, 2, 0, 1}, // 0x20 ' ' {0, 1, 5, 2, 0, 4}, // 0x21 '!' {1, 3, 2, 4, 0, 4}, // 0x22 '\"' {2, 5, 5, 6, 0, 4}, // 0x23 '#' {6, 3, 6, 4, 0, 4}, // 0x24 '$' {9, 3, 5, 4, 0, 4}, // 0x25 '%' {11, 4, 5, 5, 0, 4}, // 0x26 '&' {14, 1, 2, 2, 0, 4}, // 0x27 ''' {15, 2, 5, 3, 0, 4}, // 0x28 '(' {17, 2, 5, 3, 0, 4}, // 0x29 ')' {19, 3, 3, 4, 0, 3}, // 0x2A '*' {21, 3, 3, 4, 0, 3}, // 0x2B '+' {23, 2, 2, 3, 0, 0}, // 0x2C ',' {24, 3, 1, 4, 0, 2}, // 0x2D ' ' {25, 1, 1, 2, 0, 0}, // 0x2E '.' {26, 3, 5, 4, 0, 4}, // 0x2F '/' {28, 3, 5, 4, 0, 4}, // 0x30 '0' {30, 3, 5, 4, 0, 4}, // 0x31 '1' {32, 3, 5, 4, 0, 4}, // 0x32 '2' {34, 3, 5, 4, 0, 4}, // 0x33 '3' {36, 3, 5, 4, 0, 4}, // 0x34 '4' {38, 3, 5, 4, 0, 4}, // 0x35 '5' {40, 3, 5, 4, 0, 4}, // 0x36 '6' {42, 3, 5, 4, 0, 4}, // 0x37 '7' {44, 3, 5, 4, 0, 4}, // 0x38 '8' {46, 3, 5, 4, 0, 4}, // 0x39 '9' {48, 1, 3, 2, 0, 3}, // 0x3A ':' {49, 2, 4, 3, 0, 3}, // 0x3B ';' {50, 2, 3, 3, 0, 3}, // 0x3C '<' {51, 3, 3, 4, 0, 3}, // 0x3D ' ' {53, 2, 3, 3, 0, 3}, // 0x3E '>' {54, 3, 5, 4, 0, 4}, // 0x3F '?' {56, 3, 5, 4, 0, 4}, // 0x40 '@' {58, 3, 5, 4, 0, 4}, // 0x41 'A' {60, 3, 5, 4, 0, 4}, // 0x42 'B' {62, 3, 5, 4, 0, 4}, // 0x43 'C' {64, 3, 5, 4, 0, 4}, // 0x44 'D' {66, 3, 5, 4, 0, 4}, // 0x45 'E' {68, 3, 5, 4, 0, 4}, // 0x46 'F' {70, 3, 5, 4, 0, 4}, // 0x47 'G' {72, 3, 5, 4, 0, 4}, // 0x48 'H' {74, 1, 5, 2, 0, 4}, // 0x49 'I' {75, 3, 5, 4, 0, 4}, // 0x4A 'J' {77, 3, 5, 4, 0, 4}, // 0x4B 'K' {79, 3, 5, 4, 0, 4}, // 0x4C 'L' {81, 5, 5, 6, 0, 4}, // 0x4D 'M' {85, 4, 5, 5, 0, 4}, // 0x4E 'N' {88, 3, 5, 4, 0, 4}, // 0x4F 'O' {90, 3, 5, 4, 0, 4}, // 0x50 'P' {92, 3, 6, 4, 0, 4}, // 0x51 'Q' {95, 3, 5, 4, 0, 4}, // 0x52 'R' {97, 3, 5, 4, 0, 4}, // 0x53 'S' {99, 3, 5, 4, 0, 4}, // 0x54 'T' {101, 3, 5, 4, 0, 4}, // 0x55 'U' {103, 3, 5, 4, 0, 4}, // 0x56 'V' {105, 5, 5, 6, 0, 4}, // 0x57 'W' {109, 3, 5, 4, 0, 4}, // 0x58 'X' {111, 3, 5, 4, 0, 4}, // 0x59 'Y' {113, 3, 5, 4, 0, 4}, // 0x5A 'Z' {115, 2, 5, 3, 0, 4}, // 0x5B '[' {117, 3, 5, 4, 0, 4}, // 0x5C '\\' {119, 2, 5, 3, 0, 4}, // 0x5D ']' {121, 3, 2, 4, 0, 4}, // 0x5E '^' {122, 4, 1, 4, 0, 1}, // 0x5F '_' {123, 2, 2, 3, 0, 4}, // 0x60 '`' {124, 3, 4, 4, 0, 3}, // 0x61 'a' {126, 3, 5, 4, 0, 4}, // 0x62 'b' {128, 3, 3, 4, 0, 2}, // 0x63 'c' {130, 3, 5, 4, 0, 4}, // 0x64 'd' {132, 3, 4, 4, 0, 3}, // 0x65 'e' {134, 2, 5, 3, 0, 4}, // 0x66 'f' {136, 3, 5, 4, 0, 3}, // 0x67 'g' {138, 3, 5, 4, 0, 4}, // 0x68 'h' {140, 1, 5, 2, 0, 4}, // 0x69 'i' {141, 2, 6, 3, 0, 4}, // 0x6A 'j' {143, 3, 5, 4, 0, 4}, // 0x6B 'k' {145, 2, 5, 3, 0, 4}, // 0x6C 'l' {147, 5, 3, 6, 0, 2}, // 0x6D 'm' {149, 3, 3, 4, 0, 2}, // 0x6E 'n' {151, 3, 3, 4, 0, 2}, // 0x6F 'o' {153, 3, 4, 4, 0, 2}, // 0x70 'p' {155, 3, 4, 4, 0, 2}, // 0x71 'q' {157, 2, 3, 3, 0, 2}, // 0x72 'r' {158, 3, 4, 4, 0, 3}, // 0x73 's' {160, 2, 5, 3, 0, 4}, // 0x74 't' {162, 3, 3, 4, 0, 2}, // 0x75 'u' {164, 3, 3, 4, 0, 2}, // 0x76 'v' {166, 5, 3, 6, 0, 2}, // 0x77 'w' {168, 3, 3, 4, 0, 2}, // 0x78 'x' {170, 3, 4, 4, 0, 2}, // 0x79 'y' {172, 3, 4, 4, 0, 3}, // 0x7A 'z' {174, 3, 5, 4, 0, 4}, // 0x7B '{' {176, 1, 6, 2, 0, 4}, // 0x7C '' {177, 3, 5, 4, 0, 4}, // 0x7D '}' {179, 4, 2, 5, 0, 3} }; // 0x7E '~' const GFXfont Picopixel PROGMEM {(uint8_t *)PicopixelBitmaps, (GFXglyph *)PicopixelGlyphs, 0x20, 0x7E, 7}; ``` 字模准备完毕，我们可以点亮彩灯矩阵，并且显示ascii的字符了！ 打开工程下的src文件夹下的main.cpp。 输入以下代码： ```c #include <Arduino.h> #include <Adafruit_NeoMatrix.h> //点亮LED矩阵需要的库 #include \"my_font.h\" //引用文字库头文件 //像素阵列定义 #define kMatrixWidth 32 //宽度 #define kMatrixHeight 8 //高度 #define BRIGHTNESS 10 //默认亮度 0 255 #define BRIGHTNESS_INTERVAL 30 //亮度调节间隔 #define LED_PIN 8 //像素阵列引脚 Adafruit_NeoMatrix *matrix; //LED矩阵类指针 //像素矩阵初始化 void InitLED_Matrix(void) { //设置像素矩阵的方向以及排列方式 matrix new Adafruit_NeoMatrix(32, 8, LED_PIN, NEO_MATRIX_TOP + NEO_MATRIX_LEFT+ NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); matrix >setTextWrap(false); //设置文字是否自动换行 matrix >setFont(&Picopixel); //设置字体 matrix >clear(); //清除当前显示内容 matrix >setBrightness(BRIGHTNESS);//设置亮度 } //显示信息 void ShowMessage(Adafruit_NeoMatrix *matrix, char *message, int len, uint32_t color) { //清除上一次的显示内容 matrix >clear(); //设置文本颜色 matrix >setTextColor(color); //如果显示的内容过长，或者过小 if (len < 1 len > 8) return; //设置鼠标光标的位置用以确定在哪里显示文字 //X轴自动居中 matrix >setCursor(1 + (8 len) * 2, 5); //将显示的内容输出至缓存中 matrix >print(message); //显示缓存中的内容 matrix >show(); } void setup() { //初始化LED矩阵显示 InitLED_Matrix(); //显示 6 个字符，显示内容：Hello!，显示颜色：绿色(R,G,B) ShowMessage(matrix, \"Hello!\", 6, matrix >Color(0, 255, 0)); } void loop() { delay(1000); } ``` ## 硬件连接 ![图 3](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 17 41.png) > 这里其实我是做了电路设计的，但是模块电路都是一样的。 > ![图 4](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 17 49.png) ## 代码验证 代码编写完成之后，将ESP32S3开发板接入电脑下载代码。然后观察彩灯矩阵的现象。 实物显示如下： **裸屏显示** ![图 5](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 18 43.png) **使用黑色亚克力面板+白纸格挡光线显示** > 叠层从上到下是这样的：黑色亚克力面板 > 白纸 > LED矩阵 ![图 6](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 18 50.png) ## 示例一：显示下雨特效 ### 文件创建分类 1. 在工程下的``include`` 文件夹下新建一个 ``anim.h``文件。 2. 在工程下的``src`` 文件夹下新建一个 ``anim.cpp``文件。 ### 代码编写 在 ``anim.h`` 文件中编写以下代码： ```c #ifndef _ANIM_H_ #define _ANIM_H_ #include <Adafruit_NeoMatrix.h> #include \"Arduino.h\" //数字雨动画 void movingPixel(Adafruit_NeoMatrix *matrix, int x, int y, int colorh); void showRainingCode(Adafruit_NeoMatrix *matrix); #endif ``` 在 ``anim.cpp`` 文件中编写以下代码： ```c #include \"anim.h\" //数字雨 int columnIndex[8]; int stepIndex[8]; int glow[8]; bool Running[8] {false, false, false, false, false, false, false, false}; int stepsTillNext[8] {0, 6, 2, 11, 4, 10, 7, 1}; uint16_t hsv2rgb(Adafruit_NeoMatrix *matrix, uint16_t hue, uint8_t saturation, uint8_t value) { uint8_t red 0; uint8_t green 0; uint8_t blue 0; uint16_t hi (hue / 60) % 6; uint16_t F 100 * hue / 60 100 * hi; uint16_t P value * (100 saturation) / 100; uint16_t Q value * (10000 F * saturation) / 10000; uint16_t T value * (10000 saturation * (100 F)) / 10000; switch (hi) { case 0: red value; green T; blue P; break; case 1: red Q; green value; blue P; break; case 2: red P; green value; blue T; break; case 3: red P; green Q; blue value; break; case 4: red T; green P; blue value; break; case 5: red value; green P; blue Q; break; default: return matrix >Color(255, 0, 0); } red red * 255 / 100; green green * 255 / 100; blue blue * 255 / 100; return matrix >Color(red, green, blue); } //数字雨专用的移动像素特效 void movingPixel(Adafruit_NeoMatrix *matrix, int x, int y, int colorh) { int pixel y; matrix >drawPixel(x, pixel, hsv2rgb(matrix, colorh, 100, 100)); if(pixel 1 > 0){ matrix >drawPixel(x, pixel 1, hsv2rgb(matrix, colorh, 80, 80 ));} if(pixel 2 > 0){ matrix >drawPixel(x, pixel 2, hsv2rgb(matrix, colorh, 70, 70 ));} if(pixel 3 > 0){ matrix >drawPixel(x, pixel 3, hsv2rgb(matrix, colorh, 45, 45 ));} if(pixel 4 > 0){ matrix >drawPixel(x, pixel 4, hsv2rgb(matrix, colorh, 25, 25 ));} if(pixel 5 > 0){ matrix >drawPixel(x, pixel 5, hsv2rgb(matrix, colorh, 10, 10 ));} if(pixel 6 > 0){ matrix >drawPixel(x, pixel 6, matrix >Color(0, 0, 0));} } //显示数字雨特效 void showRainingCode(Adafruit_NeoMatrix *matrix) { for(int i 0; i<8; i++) { if(stepIndex[i] > stepsTillNext[i]) { Running[i] true; stepsTillNext[i] 13; // 进行数组初始化 columnIndex[i] random((i*4), ((i+1)*4)); glow[i] random(0, 2); //随机背景置灰值 stepIndex[i] 0; } if(Running[i] true) { movingPixel(matrix, columnIndex[i], stepIndex[i], 240); if(stepIndex[i] 13) { Running[i] false; } } stepIndex[i] + 1; } } ``` 最后在`main.cpp`中编写如果代码： ```c #include <Arduino.h> #include <Adafruit_NeoMatrix.h> //点亮LED矩阵需要的库 #include \"my_font.h\" //引用文字库头文件 #include \"anim.h\" //引用我们自定义的动画头文件 //像素阵列定义 #define kMatrixWidth 32 //宽度 #define kMatrixHeight 8 //高度 #define BRIGHTNESS 50 //默认亮度 0 255 #define BRIGHTNESS_INTERVAL 30 //亮度调节间隔 #define LED_PIN 8 //像素阵列引脚 Adafruit_NeoMatrix *matrix; //LED矩阵类指针 //像素矩阵初始化 void InitLED_Matrix(void) { //设置像素矩阵的方向以及排列方式 matrix new Adafruit_NeoMatrix(32, 8, LED_PIN, NEO_MATRIX_TOP + NEO_MATRIX_LEFT+ NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800); matrix >setTextWrap(false); //设置文字是否自动换行 matrix >setFont(&Picopixel); //设置字体 matrix >clear(); //清除当前显示内容 matrix >setBrightness(BRIGHTNESS);//设置亮度 } //显示信息 void ShowMessage(Adafruit_NeoMatrix *matrix, char *message, int len, uint32_t color) { //清除上一次的显示内容 matrix >clear(); //设置文本颜色 matrix >setTextColor(color); //如果显示的内容过长，或者过小 if (len < 1 len > 8) return; //设置鼠标光标的位置用以确定在哪里显示文字 //X轴自动居中 matrix >setCursor(1 + (8 len) * 2, 5); //将显示的内容输出至缓存中 matrix >print(message); //显示缓存中的内容 matrix >show(); } void setup() { //初始化LED矩阵显示 InitLED_Matrix(); //显示 6 个字符，显示内容：Hello!，显示颜色：绿色(R,G,B) ShowMessage(matrix, \"Hello!\", 6, matrix >Color(0, 255, 0)); delay(2000); } void loop() { //清除之前的显示内容 matrix >clear(); //设置雨滴特效 showRainingCode(matrix); //显示内容 matrix >show(); //控制雨滴下落速度 delay(250); } ``` ### 实物效果 > 烧录步骤不再描述，这里直接提供实物效果图。 **使用黑色亚克力面板+白纸格挡光线显示** > 叠层从上到下是这样的：黑色亚克力面板 > 白纸 > LED矩阵 ![图 9](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 22 51.gif) ## 示例二：显示时钟并走时 > 并不是真的显示真实时间，这里只是显示个模型，方便我们后面搞好时钟模块的驱动后使用 ### 文件创建分类 继续继用上一章节的 ``anim.h`` 和 ``anim.cpp``，位置和文件名都不变。 ### 编写代码 在``anim.h``中补充如下： ```c //时钟时钟 void weekBarDisplay(Adafruit_NeoMatrix *matrix,int week); ``` 代码页面截图： ![图 10](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 23 17.png) 在``anim.cpp`` 文件的末尾补充如下代码： ```c /**************************************数字时钟*********************************************** */ //日期显示 void weekBarDisplay(Adafruit_NeoMatrix *matrix,int week) { week week 1; for (int i 0; i < 7; i++) { if ( i 5 i 6 ) matrix >drawFastHLine(3 + 4 * i, 7, 3, matrix >Color(50, 0, 0)); else matrix >drawFastHLine(3 + 4 * i, 7, 3, matrix >Color(50, 50, 50)); } if ( week 5 week 6 ) //周六、日显示为红色 matrix >drawFastHLine(3 + 4 * week, 7, 3, matrix >Color(255, 0, 0)); else matrix >drawFastHLine(3 + 4 * week, 7, 3, matrix >Color(255, 255, 255)); } /**************************************数字时钟*********************************************** */ ``` ![图 11](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 23 24.png) 在``main.cpp`` 文件中，将``loop() `` 函数中更新为如下代码： ```c void loop() { static char disp_buf[50] {0}; static int hour 12; static int minute 59; static int second 0; static int week 2; matrix >clear();//清屏 matrix >setTextColor(matrix >Color(0, 0, 80));//设置文本颜色 matrix >setCursor(3, 5);//设置显示起始坐标 sprintf(disp_buf, \"%02d:%02d:%02d\\0\", hour, minute, second);//格式化时间字符串 matrix >print(disp_buf);//显示时分秒 weekBarDisplay(matrix,week);//显示周（特殊的显示方式） matrix >show();//更新显示 delay(1000); second second + 1; if( second > 59 ) second 0; } ``` 代码截图： ![图 12](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 23 40.png) > 代码中时钟跑时部分是随便写的，这里就是写了一个显示时间的UI框架，并不是真实时间的跑时。 ### 实物验证 > 烧录步骤不再描述，这里直接提供实物效果图。 ![图 13](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 23 52.gif) **下方显示的周数，当前是周二，所以第二个高亮** >! 说明：如果你根据代码操作运行不起来，可以下载👉[例程](https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/example/LEDMatrix)看看"},"/diy/picxel-clock/install.html":{"title":"像素时钟环境搭建","content":" title: 像素时钟环境搭建 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 安装VScode 安装的步骤网络上多的很，这里不再介绍。 ## VSCode安装PlatformIO扩展 打开VSCode的扩展安装。 ![图 0](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 46 30.png) 搜索``platformio``并进行安装。 ![图 1](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 46 44.png) 如果是第一次安装，通常是需要魔法的，毕竟服务器在海外。 ### 离线安装PIO 当点击安装时，PIO就会去github上安装对应的资源，但是github还是有很多人不知道怎么上，也不知道怎么开魔法，所以当出现下图中的提示时，马上关闭VSCode。 ![图 2](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 46 58.png) 这里提供一个PIO离线的资料包， <mark>通过网盘分享的文件：PIO资源包 <mark>链接: https://pan.baidu.com/s/1n0lSM8ngeu1Wt5uJzMze A 提取码: LGGA </mark> ![图 3](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 47 16.png) 去到C盘自己的电脑用户名下： ![图 4](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 47 25.png) 将百度网盘中下载的 <kbd>.platformio.zip</kbd>解压到你的电脑用户名文件夹下替换。替换完成后，`.platformio`文件夹中全部的文件如下： > 注意别搞错了，是将百度网盘中的内容解压到电脑用户名下替换，不要再嵌套一个.platformio文件夹。 ![图 5](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 47 40.png) ## PlatformIO介绍 打开VSCode，打开我们刚才安装的PIO. ![图 6](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 48 01.png) 界面的介绍： ![图 7](../../static/images/docs/diy/picxel clock/install/install 2024 12 05 22 48 17.png) 那么这里安装就完成了。"},"/diy/picxel-clock/voice.html":{"title":"语音识别与播报","content":" title: 语音识别与播报 keywords: keyword1, keyword2 desc: description for this article show_source: false update: date: 2024 12 05 author: 老怪鸽 version: 1.0.1 content: 更新了基本文档 ## 硬件准备 ### SU 03T语音识别模块 ![图 0](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 16 09.png) **购买地址：**[AI智能语音识别模块离线语音控制模块语音识别芯片声控模块SU 03T](https://item.taobao.com/item.htm?spm a21n57.1.item.2.5149523ciinTKe&priceTId 213e36a717250841217803005e1125&utparam %7B%22aplus_abtest%22:%224e3555425c253a0aa3856c6a58b82147%22%7D&id 622894893913&ns 1&abbucket 4&skuId 4913882832427&pisk fspsdgvloP4_MmiKcrnFOpFg24Wf1EMz5osvqneaDOBOkBtklNomsORCleLCWRoissQXSOCD_Z7NlttDPDurUY MjtXtz4kr2nBemTVADNU4pJIcs2oU8Y MjZq_k0RKUS1r0WIYMZLAp6IcXtUYHinCpgjfHRCYBWUd wQAH eAv9I5qZF9kiCd9Gj_HrFOWvBdDwQAHth8Lusj1NxsvUYbVXnPAhQQFHvCXdPMfwag7pTP1aePR evdGtLGeM_Fj7JZN5PreHUCttdce1y14w6lnKkM69bWc8JDFvCITGqj_OpTQ56OVef8dSfwtCQD KCHCCvhTH8RMApbIpM5owAjdJPGafID fVpL5JwFZmqHBODEfk342GWnKkEQWSCzj6936C4jyPPrxLGWHuhM_rADN0iX96iThjh9KF6Mj1TDiQWIfOxM_rADN0i1IhfwoIAPdc.) ### ESP32S3开发板 ![图 1](../../static/images/docs/diy/picxel clock/ledmatrix/ledmatrix 2024 12 05 23 14 24.png) **购买地址：**[立创·ESP32S3R8N8 开发板](https://item.szlcsc.com/22034693.html?fromZone s_s__%2522%25E7%25AB%258B%25E5%2588%259B%25E5%25BC%2580%25E5%258F%2591%25E6%259D%25BF%2522) ### 其他装备 1. 喇叭：`8Ω0.5W的喇叭`（这里因为我是做了PCB，所以是采用的立创商城的器件编号`C530532`，大家也可以自行采购便宜的） **购买地址：** https://item.szlcsc.com/550866.html 2. 麦克风：`灵敏度 32db` （这里因为我是做了PCB，所以是采用的立创商城的器件编号`C234013`，大家也可以自行采购便宜的） **购买地址：** https://item.szlcsc.com/233795.html 3. 给语音模块下载的设备CH340：（这里因为我是做了PCB，搭了下载电路，大家也可以自行采购淘宝上卖的CH340模块，如下图） ![图 1](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 17 03.png) ## 硬件连接 我之前说过我是设计了电路的，不是单独的接模块，所以硬件部分我会介绍电路设计方面。 ![图 2](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 19 24.png) 首先，因为语音模块需要有一个下载设备，这里直接将TYPE C接口的数据接口接到了一个CH340N（图中的U9，编号C2977777）的器件上。接下来对各个器件进行说明。 1. R56和R57是USB协议上要求的，必须是5.1K，涉及到PD诱骗电压输出，具体原因自行百度。 2. D8和D7是ESD保护器件，防止静电的，防止静电损坏后级设备，也可以不用这些器件。 3. VBUS通过一个短接符号连接到了5V，说明这个TYPE C输入的是5V，是我的个人习惯，通常可以直接在USB处标记5V。 4. U9就是之前说的CH340N，看[数据手册](https://atta.szlcsc.com/upload/public/pdf/source/20230530/6E401E9554E9F5311886CC8B3F89B62E.pdf)，是一个将USB 转串口的芯片，而我们的语音识别模块就是通过串口下载。 5. C26和C27，首先是C26，在CH340N的数据手册中指出：当CH340N的电压输入为5V时，必须在V3引脚处外接一个100nf的电容；VCC处尽量加一个100NF的电容。 6. R27和D1，根据CH340N的厂家说明，为了防止与CH340N通信的设备，通过RXD和TXD引脚将电压反充给CH340，建议在RXD引脚上接入一个限流电阻，TXD上接一个反向二极管，防止电流电压倒灌。 7. D2也是一个ESD器件，防止类似雷击，静电等导致的瞬间高压损坏设备，加入ESD器件后，可以有效防止瞬间的高压将设备烧毁。 **总结：就是一个通过USB供电的同时，还可以通过USB给语音模块下载语音识别的固件** ![图 3](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 19 46.png) 下面就是SU 03T语音识别模块的外围电路，下面是对各个器件的介绍： 1. 因为这个语音识别模块在下载固件时，必须在保持断电的情况下，在电脑上点击下载，然后再通电才能够下载成功。为了实现这个断电下载操作，加了一个拨码开关（SW1）。 2. C19的作用是储能，必须语音识别模块感觉还是电流消耗挺大的，加一个10UF的电容，在没有电流时就从C19供电。 3. 语音采集的框图中的32DB只的就是这个麦克风是 32DB的一个麦克风，或者叫咪头。 4. SPK1就是喇叭。 5. 图中的03TTXD和03TRXD就是接到了CH340N的串口通信线上，语音固件就是通过这两根线进行固件下载。 6. B2TX和B3RX是接到了开发板上的GPIO13和GPIO12，开发板将这两个引脚设置为串口通信，语音模块也将B2B3设置为串口通信，这样才可以数据互传。 这个很重要，因为该语音模块只能设置B2和B3为串口。 使用模块的接线图： ![图 4](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 19 56.png) ## 语音识别的命令词设置 ### 新建产品 进入在线的配置平台： [智能公元零代码平台](https://smartpi.cn/#/)，没有注册的先注册然后登录。 ![图 5](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 03.png) 去到产品管理下。 ![图 6](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 07.png) 新建一个产品 ![图 7](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 13.png) 产品配置. ![图 8](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 18.png) ### 语音信号处理配置 下面是我的配置截图： ![图 9](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 23.png) ### 引脚配置 引脚设置中，选择B2和B3为串口，串口的其他参数默认。 ![图 10](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 27.png) ### 唤醒词配置 唤醒词的设置。该模块是一个二级语音命令的模块，类似与小爱同学，你得先通过唤醒词将模块唤醒，然后才能够进行下一步的语音命令。这里我设置了三个唤醒词，当语音模块识别到唤醒词时，会播报下面的唤醒回复。 ![图 11](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 41.png) ### 命令词自定义 命令词自定义。图中的`行为`栏可以随便写不重要；但是`触发方式`栏得注意，命令词表示当识别到我们的语音命令时就会触发的意思，而串口输入，就是当接收到我们开发板通过串口发送给模块的特点格式的串口数据时，才会触发。`命令词`栏是当`触发方式`栏为命令词时才可以输入，输入的内容就是你要说什么语音，他才会触发这个命令，而``的意思就是可以设置多个命令词。当命令词被触发时，可以设置是否要语音模块进行回复，回复内容在`回复语`栏中配置。 ![图 12](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 46.png) 点击控制栏：可以设置当命令触发时，需要控制语音模块做什么操作。 ![图 13](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 20 50.png) 动作参数的设置方式：**（GIF）** > 这里除了串口外，还可以设置其他的动作，大家自行了解。 ![图 14](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 21 02.gif) 我设置的控制参数如下。 ```c 语音表 帧头 数据 帧尾 说明 EF 00 FE 被语音唤醒，唤醒词：小豆小豆小豆同学你好小豆 EF 01 FE 识别到语音：当前温湿度现在温湿度现在的温湿度温湿度是多少 EF 02 FE 识别到语音：当前时间现在时间现在的时间现在是什么时候了现在多少点了现在时间是多少报时 EF 03 FE 识别到语音：显示时间切换时间界面切换时间显示时钟切换时钟界面切换时钟 EF 04 FE 识别到语音：显示天气切换天气切换天气界面显示天气界面 EF 05 FE 识别到语音：显示温湿度切换温湿度切换温湿度界面显示温湿度界面 EF 06 FE 识别到语音：显示数字雨切换数字雨切换数字雨界面显示数字雨界面 EF 07 FE 识别到语音：显示频谱灯显示音律灯切换频谱灯切换音律灯切换频谱灯界面切换音频灯界面显示频谱灯界面显示音律灯界面 EF 08 FE 识别到语音：显示切换切屏界面切换切换界面显示下一个 ``` 当开发板的串口接收到 `EF 00 FE` 时，说明语音模块触发了唤醒词命令；当开发板的串口接收到 `EF 01 FE` 时，说明语音模块触发了当前温湿度的命令。其它同理。为了方便接收并解析多条命令，这里设置成为了帧头帧尾的格式。当串口接收到`FE`说明语音识别模块触发了命令，分析上一个接收的数据，则可以知道是识别的哪一个命令。 例如：语音识别模块发来了命令：`EF 04 FE` ```C if( RX_BUFF[DATA_LEN] 0XFE )//接收到帧尾 { if( RX_BUFF[DATA_LEN 2] 0XEF ) //确定上上个接收到的数据是帧头，确定数据格式正确 { SU03T_data cRX_BUFF[DATA_LEN 1]; //接收中间的数据 } } ``` > 0X在代码中表示的是十六进制的数据，而语音模块发送的EF/FE等数据就是十六进制 除了以上的动作参数外，大家还记得之前设置的串口输入命令吗？`当识别到我们设置的特殊格式的串口命令，语音模块将会被触发。`,这个特殊格式的串口命令就是这这里设置的： ![图 15](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 21 24.png) 触发命令的配置步骤：**( GIF )** ![图 16](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 21 34.gif) 这样当我们发送格式 AA 55 02 1A 46 55 AA 时，语音模块就会知道我们发送给它的数据是什么了。 帧头 消息编号 温度数据 湿度数据 帧尾 AA 55 02 1A 44 55 AA * 帧头帧尾是在引脚配置时，设置的。 * 消息编号是在设置触发时设置的。 * 而这个温度和湿度数据，表示的是发送一个`char`型的变量，填充改数据。比如我们要将温度12，湿度70这两个数据发送给语音模块，需要先将数据转换为16进制，12的十六进制为0C，70的十六进制为46，则发送这个：<kbd>AA 55 02 0C 70 55 AA</kbd>，则语音模块就会知道，接收到了02号设备的数据 12 和 46了。 我们现在知道了接收数据的格式怎么发送了，接下来看看该命令的动作参数配置步骤：**（GIF）** ![](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 22 13.gif) 这里继承了之前接收到的数据变量 `temp` 和 `humi`，这个`temp`就是我们发送的温度数据，`humi`就是我们发送的湿度数据， > 数据变量是在配置触发命令时设置的。 看图大家应该也知道了，就是模块接收到我们发送过去给它的特殊格式的串口数据时，它会取出其中的数据，并通过我们的设置将数据播报出来。比如拿之前的举的例子： > 我们要将温度12，湿度70这两个数据发送给语音模块，需要先将数据转换为16进制，12的十六进制为0C，70的十六进制为46，则发送这个：<kbd>AA 55 02 0C 70 55 AA</kbd>，则语音模块就会知道，接收到了02号设备的数据 12 和 70了。当语音模块接收到数据后，又会根据我们的动作设置进行播报：`当前温度是 12 摄氏度，当前湿度是百分之 46` **以下是我的两个串口命令表：** 串口触发命令 播报的内容 AA 55 01 hour min 55 AA 当前时间为 hour 点 min 分 AA 55 02 temp humi 55 AA 当前温度是 temp 摄氏度，当前湿度是百分之 humi ### 免唤醒词和误识别词配置 这里我没有配置太多，就配置了一个当前时间语音。可以不用触发唤醒词，直接说`当前时间`就可以触发。 ![图 18](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 23 23.png) ### 发音人配置 大家选择一个自己喜欢的就好，然后音量方面，我个人认为音量有点大，就设置为了36%左右的音量。 ![图 19](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 23 28.png) ### 其他配置 在 其他配置 中建议大家开启这个 `开机播报`功能，防止大家忘记唤醒词，所以可以通过开机播报，每次开机都让模块“自我介绍”。 ![图 20](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 23 35.png) 其他的内容如下：完全不用管 ![图 21](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 23 41.png) ### 发布新版本 点击发布新版本，这个平台就会去生成你自己的语音固件了，通常生成的时间比较久，得等大概10~30分钟左右。 ![图 22](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 23 46.png) ### 下载固件和烧录软件 固件生成之后，去到你对应的产品管理下，下载你的固件。**(GIF)** ![图 23](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 24 21.gif) 点击下载固件后，如图：（jx_firm (2).tar.gz就是语音固件） ![图 24](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 24 46.png) 这里需要注意，你还需要下载语音固件的烧录工具，烧录工具中<kbd>更多</kbd>下的<kbd>下载SDK</kbd>中。 ![图 25](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 24 53.png) SDK的下载： ![图 26](../../static/images/docs/diy/picxel clock/voice/voice 2024 12 06 00 24 58.png) ### 语音固件的下载 `在下载固件时，要先将模块断电。待下载工具识别到模块之后，再给模块通电，才可以正常下载。`这个通断电操作，由原理图中的SW1开关进行控制。如果大家不是像我一样使用PCB连接的，那使用CH340模块给SU 03T供电，在下载前将VCC的电源拔掉，在软件上点下载之后再连接VCC。 具体的烧录步骤视频：[视频地址](https://www.bilibili.com/video/BV1r5nZe3EsN/) <iframe src \"//player.bilibili.com/player.html?isOutside true&aid 113055635604214&bvid BV1r5nZe3EsN&cid 25672351903&p 1&autoplay 0\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"width: 100%; margin: auto; display: block; height: 800px\"></iframe> ## PIO工程创建 在VSCode中打开PlatformIO扩展创建名为`voiceSu03t`的 `Espressif ESP32 S3 DevKitM 1` 工程。 关于详细图文创建工程的过程请参考👉[RTC时钟驱动](ds1302.html)章节的工程创建小节。 ## 编辑代码 在工程里的`src`文件夹下，新建一个 `voiceSu03t.cpp` 文件。 在工程里的`include`文件夹下，新建一个 `voiceSu03t.h` 文件。 往`voiceSu03t.cpp` 文件中写入如下代码： ```cpp #include \"voiceSu03t.h\" #include \"stdio.h\" //串口中断服务函数，请务必在main.cpp中定义并且实现该文件 void IRAM_ATTR voiceSerialReceive(); VOICESU03T::VOICESU03T(int8_t uart_num, int8_t tx_pin, int8_t rx_pin, uint32_t baud_rate) { _uart_num uart_num; _tx_pin tx_pin; _rx_pin rx_pin; _baud_rate baud_rate; switch (_uart_num) { case 1: serial &Serial1; break; case 2: serial &Serial2; break; // 可以根据需要添加更多串口 } } //语音模块串口接口初始化 void VOICESU03T::begin() { if (serial) { serial >begin(_baud_rate, SERIAL_8N1, _rx_pin, _tx_pin); // 注册中断服务例程 serial >onReceive(voiceSerialReceive); } } //向语音模块发送串口数据 size_t VOICESU03T::write(uint8_t *data, size_t size) { if (serial) { return serial >write((const uint8_t *)data, size); } return 0; } //读取语音模块发送过来的串口数据 int VOICESU03T::read() { if (serial) { return serial >read(); } return 1; } //当前接收到的语音模块内容缓存长度 int VOICESU03T::available() { if (serial) { return serial >available(); } return 0; } void VOICESU03T::setState(int8_t state) { _state state; } int8_t VOICESU03T::getState() { return _state; } //将10进制转换为16进制的HEX //参数：decimal（传入的10进制数） //返回：16进制hex long VOICESU03T::decimalToHex_big(long decimal) { \tlong hex 0; \tint i 0; \tchar temp_buff[20]; \t \tsprintf(temp_buff, \"%lX\", decimal);//换为字符串的16进制 \t//根据字符串长度一直转换 \tfor( i 0 ; temp_buff[i] ! '\\0'; i++ ) \t{ \t\t//如果是数字 \t\tif( temp_buff[i] > '0' && temp_buff[i] < '9' ) \t\t{ \t\t\thex (hex << 4) temp_buff[i] '0'; \t\t} \t\telse//如果是字母 \t\t{ \t\t\tswitch( temp_buff[i] ) \t\t\t{ //先左移再转换 \t\t\t\tcase 'A':\thex (hex << 4) 0x0A;\tbreak; \t\t\t\tcase 'B':\thex (hex << 4) 0x0B;\tbreak; \t\t\t\tcase 'C':\thex (hex << 4) 0x0C;\tbreak; \t\t\t\tcase 'D':\thex (hex << 4) 0x0D;\tbreak; \t\t\t\tcase 'E':\thex (hex << 4) 0x0E;\tbreak; \t\t\t\tcase 'F':\thex (hex << 4) 0x0F;\tbreak; \t\t\t} \t\t} \t} \treturn hex; } //发送语音播报当前时间的命令 //hour 小时数据,min 分钟数据 void VOICESU03T::voiceSpeechTime(long hour, long min) { unsigned char sendBuff[7] { 0xAA, 0X55, 0X01, 0X00, 0X00, 0X55, 0xAA }; sendBuff[3] decimalToHex_big(hour); sendBuff[4] decimalToHex_big(min); write(sendBuff, 7); } //发送语音播报当前温湿度的命令 //temp 温度数据,humi 湿度数据 void VOICESU03T::voiceSpeechHumiture(long temp, long humi) { unsigned char sendBuff[7] { 0xAA, 0X55, 0X02,0X00, 0X00, 0X55, 0xAA }; sendBuff[3] decimalToHex_big(temp); sendBuff[4] decimalToHex_big(humi); write(sendBuff, 7); } ``` 往`voiceSu03t.h` 文件中写入如下代码： ```cpp #ifndef VOICESU03T_H #define VOICESU03T_H #include \"HardwareSerial.h\" class VOICESU03T { public: VOICESU03T(int8_t uart_num, int8_t tx_pin, int8_t rx_pin, uint32_t baud_rate); void begin(); size_t write(uint8_t *data, size_t size); int read(); int available(); void setState(int8_t state); int8_t getState(); long decimalToHex_big(long decimal); void voiceSpeechTime(long hour, long min); void voiceSpeechHumiture(long temp, long humi); private: HardwareSerial *serial; int8_t _uart_num; int8_t _tx_pin; int8_t _rx_pin; uint32_t _baud_rate; int8_t _state; }; #endif // ESP32_EXTRA_UART_H ``` 往 `main.cpp` 文件中写入以下代码： ```cpp #include <Arduino.h> #include \"voiceSu03t.h\" //语音识别模块定义 #define VOICE_PORT 1 //语音识别模块使用的串口 #define VOICE_TX_PIN 12 //语音识别模块使用的串口TX引脚 #define VOICE_RX_PIN 13 //语音识别模块使用的串口RX引脚 #define VOICE_TX_BAUDRATE 9600 //语音识别模块使用的串口波特率 //创建语音识别对象 VOICESU03T Su03t(VOICE_PORT, VOICE_TX_PIN, VOICE_RX_PIN, VOICE_TX_BAUDRATE); char su03t_rx_buff[20]; char su03t_rx_len; //虚拟温湿度数据 int temperature 26; int humidity 70; //虚拟时间数据 int hour 12; int minute 59; /* 语音表 帧头 数据 帧尾 说明 EF 00 FE 被语音唤醒，唤醒词：小豆小豆小豆同学你好小豆 EF 01 FE 识别到语音：当前温湿度现在温湿度现在的温湿度温湿度是多少 EF 02 FE 识别到语音：当前时间现在时间现在的时间现在是什么时候了现在多少点了现在时间是多少报时 EF 03 FE 识别到语音：显示时间切换时间界面切换时间显示时钟切换时钟界面切换时钟 EF 04 FE 识别到语音：显示天气切换天气切换天气界面显示天气界面 EF 05 FE 识别到语音：显示温湿度切换温湿度切换温湿度界面显示温湿度界面 EF 06 FE 识别到语音：显示数字雨切换数字雨切换数字雨界面显示数字雨界面 EF 07 FE 识别到语音：显示频谱灯显示音律灯切换频谱灯切换音律灯切换频谱灯界面切换音频灯界面显示频谱灯界面显示音律灯界面 EF 08 FE 识别到语音：显示切换切屏界面切换切换界面显示下一个 */ void voiceAnalysis(char* rx_buff) { if( rx_buff[0] 0XEF ) { if( rx_buff[2] 0xFE ) { Su03t.setState(rx_buff[1]); //接收语音模块格式帧的关键数据 switch (rx_buff[1]) { case 0x01://当前温湿度现在温湿度现在的温湿度温湿度是多少 Su03t.voiceSpeechHumiture(temperature,humidity); break; case 0x02://当前时间现在时间现在的时间现在是什么时候了现在多少点了现在时间是多少报时 Su03t.voiceSpeechTime(hour,minute); break; case 0x03://显示时间切换时间界面切换时间显示时钟切换时钟界面切换时钟 Serial.printf(\"显示时间界面\"); break; case 0x04://显示天气切换天气切换天气界面显示天气界面 Serial.printf(\"显示天气界面\"); break; case 0x05://显示温湿度切换温湿度切换温湿度界面显示温湿度界面 Serial.printf(\"显示温湿度界面\"); break; case 0x06://显示数字雨切换数字雨切换数字雨界面显示数字雨界面 Serial.printf(\"显示数字雨界面\"); break; case 0x07://显示频谱灯显示音律灯切换频谱灯切换音律灯切换频谱灯界面切换音频灯界面显示频谱灯界面显示音律灯界面 Serial.printf(\"显示频谱灯界面\"); break; case 0x08://显示切换切屏界面切换切换界面显示下一个 Serial.printf(\"界面切换\"); break; default: break; } } } } // 定义一个语音识别串口的中断服务函数 void voiceSerialReceive() { // 当有数据到达时，此函数会被调用 while (Su03t.available()) { // 读取数据 su03t_rx_buff[su03t_rx_len++] Su03t.read(); if( su03t_rx_len > 3 ) //如果数据长度超过要求 { voiceAnalysis(su03t_rx_buff); //数据解析并执行对应功能 for(int i 0;i<10;i++)su03t_rx_buff[i] 0;//清除接收的数据 su03t_rx_len 0;//接收数据的长度清零 } } } void setup() { Serial.begin(9600); //调试串口初始化 Su03t.begin(); //语音模块串口初始化 } void loop() { delay(50); } ``` ## 代码验证 代码编写完成之后，将ESP32S3开发板接入电脑下载代码，然后对语音模块说命令词查看现象。 > 下载步骤请参考👉[RTC时钟驱动](ds1302.html)章节的代码验证小节。 **实验现象：对语音模块说我们之前设置的命令都是有响应回复的** > 当前例程中的温度、湿度、小时、分钟等数据都是**固定的，是假的**。大家自行调整 现象视频：https://live.csdn.net/v/embed/421316 >! 说明：如果你根据代码操作运行不起来，可以下载👉[例程](https://gitee.com/laoguaige/esp32 s3 r8 n8 pixel clock/tree/master/example/voiceSu03t)看看"}}